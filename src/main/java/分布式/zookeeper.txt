ACID
    原子性（Atomicity）

        事务的原子性是指事务必须是一个原子的操作序列单元，事务中包含的各项操作在一次执行过程中，只允许出现以下两种状态之一
            1，全部成功执行
            2，全部不执行
         任何一项操作失败都将导致整个事务失败，同时其他已经被执行的操作都将被撤销并回滚，只有所有的操作全部成功，整个事务才算成功

    一致性（Consistency）

        事务的一致性是指事务的执行不能破坏数据库的完整性和一致性，一个事务在执行之前和执行之后，数据库都必须处于一致性状态。

    隔离性（Isolation）

        事务的隔离性是指在并发环境中，并发的事务是相互隔离的，一个事务的执行不能被其他事务干扰，也就是说，不同的事务并发操作相同的数据时，每个是事务都是各自完整的数据空间。
        即一个事务内部的操作及使用的数据对其他并发事务是隔离的，并发执行的各个事务之间不能互相干扰

        4个隔离级别
            1，未授权读取（Read Uncommitted） 读未提交，该隔离级别允许脏读取，其隔离级别最低，换句话说，如果一个事务正在处理某一数据，并对其进行更新，但同时尚未完成事务，因此
            还没有进行事务提交，而与此同时，允许另一个事务也能够访问数据。事务A执行过程阶段，事务B能够看到事务A操作过程中的所有中间值

            2，授权读取（Read Committed） 未授权读取非常相近，唯一的区别是授权读取只允许获取已经被提交的数据。事务A操作的中间值，事务B是无法看到的，只能看到最终值

            3，可重复读取（Repeatable Read） 保证在事务处理过程中，多次读取同一个数据时，其值都和事务开始时刻是一致的，因此该事务级别禁止了不可重复读取和脏读取，但是有可能出现幻影数据
               幻影数据指同样的事务操作，在前后两个时间段内执行对同一个数据项的读取，可能出现不一致的结果，在上面的例子，可重复读取隔离级别能够保证事务B在第一次事务操作过程中，始终对数据
               项读取1，但是在下一次事务操作中，即使事务B采用同样的查询方式，就可能会读取到10或20

            4，串行化（Serializable）是最严格的事务隔离级别，它要求所有事务都被串行执行，即事务只能一个接一个的进行处理，不能并发执行

            隔离级别                脏读                                         可重复读                           幻读
            未授权读取             存在                                            不可以                             存在
            授权读取               不存在                                          不可以                             存在
            可重复读取             不存在                                          可以                               存在
            串行化                 不存在                                          可以                              不存在

       1、脏读：事务A读取了事务B更新的数据，然后B回滚操作，那么A读取到的数据是脏数据

       2、不可重复读：事务 A 多次读取同一数据，事务 B 在事务A多次读取的过程中，对数据作了更新并提交，导致事务A多次读取同一数据时，结果 不一致。

       3、幻读：系统管理员A将数据库中所有学生的成绩从具体分数改为ABCDE等级，但是系统管理员B就在这个时候插入了一条具体分数的记录，当系统管理员A改结束后发现还有一条记录没有改过来，
          就好像发生了幻觉一样，这就叫幻读。

    持久性（Durability）

        事务的持久性也被称为永久性，是指一个事务一旦提交，它对数据库中对应数据的状态变更就应该是永久性的，换句话说，一旦某个事务成功结束，那么他对数据库所做的更新就必须被永久保存下来

ZooKeeper
    ZooKeeper是一个典型的分布式数据一致性的解决方案，分布式应用程序可以基于它实现数据发布/订阅，均衡负载，命名服务，分布式协调，集群管理，Master选举，分布式锁，分布式队列等

    ZooKeeper可以保证分布式一致性特性
        1，顺序一致性    从同一个客户端发起的事务请求，最终将会严格按照其发起顺序被应用到ZooKeeper中
        2，原子性     所有事务请求的处理结果在整个集群中所有机器上的应用情况是一致的。
        3，单一视图   一旦服务端成功的应用了一个事务，并完成对客户端的响应，那么该事务所引起的服务端状态的变更将会被一直保留下来，除非有另一个事务又对其进行了变更
        4，实时性    通常人们看到实时性的第一反应是，一旦一个事务被成功应用，那么客户端能够独立即从服务端上读取这个事务变更后的最新数据状态，这里需要注意的是，ZooKeeper
                    仅仅保证在一定的时间段内，客户端最终一定能够从服务端上读取到最新的数据状态

    ZooKeeper的基本概念
        1，集群角色
            a,Leader
                集群通过一个Leader选举来选定一台被称为‘Leader’的机器，Leader服务器为客户端提供读和写服务
                        主要工作：
                                a,事务请求的唯一调度和处理者，保证集群事务处理的顺序性
                                b，集群内部各服务器的调度者
            b,Follower
                Follower能够提供读服务
                        主要工作：
                                a，处理客户端非事务请求，转发事务请求给Leader
                                b，参与事务请求Proposal的投票
                                c，参与Leader选举投票
            c,Observer
                Observer也能提供读服务，区别是Observer不参加Leader选举。也不参加写操作的“过办写成功”策略
                     主要工作：
                        观察ZooKeeper集群的最新状态并将这些状态同步过来，Observer服务器在工作原理上和Follower基本一致，对于非事务请求，可以进行独立处理，对于事务请求，则会转发给Leader服务器处理
         2，会话（Session）
            Session是指客户端会话，在ZooKeeper中，一个客户端连接是指客户端和服务器之间的一个TCP长连接，默认端口是2181，Session的sessionTimeout值来设置一个客户端会话的超时时间
            ，当服务器由于压力大，网络故障，主动断开连接等各种原因导致客户端断开时，只要在时间内连上任意一台服务器，那么之前创建的会话仍然有效

         3，数据节点
             ZooKeeper中节点分为两类
                1，同样构成集群的机器
                2，数据模型中的数据单元 称为ZNode ZNode可以分为持久节点和临时节点
                    持久节点 ：是指一旦被创建了，除非主动进行移除，否则会一直保存
                    临时节点 ：生命周期和客户端会话绑定，一旦客户端失效，那个客户端创建的临时节点都会被移除
         4，版本
            ZooKeeper在每个Znode上会维护一个Stat的数据结构，记录三个数据版本分别是version（当前ZNode的版本），cversion(当前Znode子节点的版本)，aversion(当前Znode的ACL版本)

         5，Watcher
            事件监听，ZooKeeper允许用户在指定的节点注册一些Watcher，并且在一些特定的事件触发时候，ZooKeeper服务端会将事件通知到感兴趣的客户端上

         6，ACL
             ZooKeeper采用ACL策略来进行权限控制
                CREATE 创建子节点的权限
                READ 获取节点数据和子节点列表的权限
                WRITE 更新节点数据的权限
                DELETE 删除子节点的权限
                ADMIN  设置节点ACL的权限

                CREATE和DELETE是针对子节点的权限控制

    ZAB协议
        所有的事务请求必须有一个全局唯一的服务器来协调处理，这样的服务器被称为Leader服务器，剩下的服务器则为Follower，Leader服务器负责讲一个客户端事务请求转换成一个事务Proposal（提议）
        并经该Proposal分发给集群中所有的Follower服务器，之后Leader服务器需要等待所有的Follower服务器的反馈，一旦超过半数Follower给了正确的反馈后，Leader就会再次向所有的Follower服务器
        分发Commit消息，要求其将前一个Proposal进行提交


    Leader选举
        1，服务器启动期的选举
            a，每个server会发出一个投票
                初始阶段会投给自己，（myid，ZXID）
            b，接受来自各个服务器的投票
                每个服务器接受其他服务器的投票，集群中的每个服务器在接受到投票后，会判断该投票的有效性，包括检查本轮投票
            c，处理投票
                接受服务器的投票后，针对每一个投票，服务器需要将别人的投票和自己PK
                    1，优先检查ZXID，ZXID比较大的服务器优先作为Leader
                    2，如果ZXID相同的话，就比较myid,myid比较大的服务器作为Leader
            d，统计投票
            e，改变服务器状态

        2，服务器运行期间的Leader选举
            a，变更状态
                当Leader挂了之后，余下的非Observer服务器都会将自己的服务器状态变更为LOOKING，然后开始进入Leader选举流程
            b，每个Server会发出一投票
            c，接受来自各个服务器的投票
            d，处理投票
            e，统计投票
            f，改变服务器状态
    SID：服务器ID    是一个数字，来唯一标识一台ZooKeeper集群中的机器，每台机器不能重复，和myid的值一致
    ZXID：事务ID   是一个事务ID，用来唯一标识一次服务器状态的变更，在某一时刻，集群中每台机器的ZXID值不一定全都一致，这和ZooKeeper服务器对于客户端“更新请求”的处理逻辑有关
    Vote：投票   Leader选举，通过投票来实现，当集群中的机器发现自己无法检测到Leader机器的时候，就会开始尝试进行投票
    Quorum: 过半机器数   ZooKeeper集群中过半的机器数，如果集群中总的机器数是N  quorum = (n/2+1)




















