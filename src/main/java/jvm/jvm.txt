1,程序计数器
    是一块较小的内存空间，可以看做是当前线程所执行的字节码的行号指示器。
    字节码解释器工作时就是通过改变这个计数器的值来取下一条需要执行的字节码指令，分支，循环，跳转，异常处理，线程恢复等基础功能都要依赖这个计数器

    由于Java虚拟机的多线程通过线程轮流分配处理器执行时间的方式来实现的，在任何一个确定的时刻，一个处理器都只会执行一条线程中的指令，因此，为了线程切换后能恢复到正确的执行位置
    每条线程需要一个独立的程序计数器，各线程之间的计数器互不影响，独立存储，我们称这类内存区域为 “线程私有” 的内存

    如果线程正在执行的是一个Java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址，如果正在执行的是Native方法，这个计数器值则为空.
    此内存区域是唯一一个在Java虚拟机中没有规定任何OutOfMemoryError情况的区域


2，Java虚拟栈
    和程序计数器一样，Java虚拟机栈也是线程私有的，他的生命周期与线程相同，虚拟机栈描述的是Java方法执行的内存模型，每个方法执行时都会创建一个栈帧
    用于存储局部变量表，操作数栈，动态链接，方法出口等信息，每一个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机中入栈到出栈的过程
    我们通常的 栈 就是现在的虚拟机栈，局部变量表存放了编译期可知的各种基本数据类型，对象引用，和returnAddress类型
    局部变量表所需的内存空间在编译期间完成分配，当进入一个方法时，这个方法需要在帧中分配多大的局部变量空间完全是确定的，在方法运行期间不会改变的
    这个区域规定两两种异常
        1，如果线程请求的栈深度大于虚拟机所允许的深度，抛出StackOverflowError异常
        2，如果虚拟机栈可以动态的扩展，如果扩展时无法申请到足够的内存，会抛出OutMemoryError


3,本地方法栈
    本地方法栈和虚拟机栈所发挥的作用是非常相似的，他们之间的区别不过是虚拟机栈为虚拟机执行Java方法服务，而本地方法栈则为虚拟机使用到的Native方法服务


4，Java堆
    对于大多数应用来说，Java堆是Java虚拟机所管理的内存中内存最大的一块。Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建，此区域唯一的目的就是存放对象实例
    几乎所有的对象实例都在这里分配内存
    Java堆是垃圾回收管理器的主要区域，因此很多时候也被称为 GC堆 从内存回收的角度来看，由于现在收集器基本采用分代收集算法，所以Java堆中可以细分为：新生代和老年代
    Java堆可以是物理上不连续的内存空间中，只要逻辑上是连续的即可，就像我们的磁盘空间一样。来实现时，即可以实现成固定大小的，也可以扩展的，现在主流都是可以扩展的
    （通过-Xmx和-Xms控制）如果堆中没有内存完成实例分配，并且堆也无法在扩展，会抛出OutOfMemoryError

5，方法区
    方法区与Java堆一样，在各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息，常量，静态变量，即时编译器编译后的代码数据，虽然Java虚拟机规范把方法区描述为堆
    的一个逻辑部分，但是它却有一个别名叫做Non-Heap（非堆） 目的是与Java堆区分开来  Java虚拟机规范对方法区的限制非常宽松，除了和Java堆一样不需要连续的内存和选择固定大小
    或者可扩展外，还可以选择不实现垃圾回收，相对而言，垃圾回收再这一区域比较少出现，这区域的内存回收目标主要是针对常量池的回收和对类型的卸载。

6，运行时常量池
    运行时常量池是方法区的一部分，class文件中除了有类的版本，字段，方法，接口等描述信息外，还有一项是常量池，用于存放编译期生成的各种字面量和符号引用，这部分内容在类加载后
    进入方法区的运行时常量池中存放
    Java虚拟机对class文件每一部分（包括常量池）的格式有着严格的规定，每一个字节用于存储哪种数据都必须符合规范上的要求才会被虚拟机认可，装载和执行，但对于运行时常量池，Java
    虚拟机规范没有做任何细节的要求

7，直接内存
    直接内存并不是虚拟机运行时数据区的一部分，也不是Java虚拟机规范中定义的内存区域，但这部分内存也被频繁使用，也可能导致OutOfMemoryError异常

主流的商用程序语言，通过可达性分析来判定对象是否存活的，这个算法的基本思想是通过一系列的称为GC Roots的对象作为起点，丛这些节点开始向下搜索，搜索所走过的路劲称为引用链
当一个对象到GC Roots没有任何引用链相连，则证明此对象是可也用的
在Java语言中，可作为GC Roots的对象包括下面几种
    虚拟机栈中的引用对象
    方法区中静态属性引用对象
    方法区中常量引用的对象
    本地方法栈中JNI（一般说的Native方法）引用的对象

1，强引用
    是指在程序代码之中普遍存在的，类似Object obl = new Object()这类的引用，只要加强引用还在，垃圾回收器永远不会回收掉被引用的对象

2，软引用
    用来描述一些还在用但并非必须的对象，对于软引用关联着的对象，在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围之中进行二次回收。
    如果这次回收还没有足够的内存，才会抛出内存溢出异常

3，弱引用
    用来描述非必须对象的，但他的强度比软引用更弱一些，被弱引用关联的对象只能存到下一次垃圾收集发生之前，当垃圾收集工作时，无论当前内存是否足够
    都会回收掉只被弱引用关联的对象

4，虚引用
    也被称为幽灵引用或者幻影引用，他是最弱的一种引用关系，一个对象是否有虚引用存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例
    为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系列通知。


回收方法区
    Java虚拟机规范中确实说过可以不要求虚拟机在方法区实现垃圾回收，而且在方法区中进行垃圾回收，性价比很低，在堆中，尤其是在新生代中，常规应用进行一次垃圾收集可以回收70%-95%的空间
    而永久代的垃圾收集效率远低于此。永久代的垃圾收集主要回收两部分内容：废弃常量和无用的类  回收废弃常量与回收Java堆中的对象非常类似
    类需要同时满足下面3个条件才能算是“无用的类”
    1，该类所有的实例都已经被回收，也就是Java堆中不存在该类的任何实例
    2，加载该类的classloader已经被回收
    3，该类对应的Java.lang.class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法
    虚拟机可以对满足上3个条件的无用类进行回收，这里说的仅仅是可以，而并不是和对象一样，不使用了就必然回收，是否对类回收，HotSpot虚拟机提供了-Xnoclassgc参数进行控制


垃圾回收算法
    1，标记-清楚算法
       最基础的收集算法是标记-清除算法，算法分为“标记"和”清除“两个阶段，首先标记处需要回收的对象，在标记完成后统一回收所有标记的对象。他的不足
       1，效率问题，标记和清除两个过程的效率都不高
       2，空间问题，标记清除后会产生大量的不连续的内存碎片，空间碎片太多可能会导致以后再程序运行过程中需要分配较大对象时，无法找到足够的连续内存而不得不提前触发垃圾收集动作

    2，复制算法
        为了解决效率问题，一种称为 复制 的收集算法出现了，它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块，当这一块的内存用完了，就将还存活着的对象复制到另外一块上
        然后把已经使用过的内存一次清理掉，这样内存分配时也就不用考虑内存碎片等复杂情况，这种算法代价是将内存缩小为了原来的一半
        现在的商业虚拟机都采用这种算法来回收新生代，新生代中的对象98%是朝生夕死，所以不需要按照1:1 分为 一块大的Eden和两块小的survivor空间。回收时将Eden和survivor中还存活的对象一次
        复制到另外一个survivor，清理掉Eden和survivor，HotSpot虚拟机默认的Eden和survivor的比例是8:1 ，也就是每次新生代中可使用内存空间为整个新生代容量的90%，当survivor空间不够时需要依赖
        其他内存（老年代）进行分配担保
        就好比我们去银行借款，98%都可以按时偿还，只需要一个担保人能在我们不能偿还的时候，可以从他的账户扣钱就可以了，内存的分配也是一样，如果survivor空间没有足够的内存存放上一次新生代收集
        下来存活对象时，这些对象直接通过分配担保机制进入老年代。

    3，标记-整理算法
        复制收集算法在对象存活率较高时会进行较多的复制操作，效率会变低，如果不想浪费50%的空间，就需要额外的空间进行分配担保，以应对内存中所有对象100%存活的极端情况，所以老年代一般不能直接
        用这种算法
        标记过程和标记清除算法一样，但后续步骤不是直接对可回收对象进行清理，而是让存活对象向一端移动，然后直接清理掉边界以外的内存

    4，分代收集算法
        当前的商业虚拟机都采用分代收集算法，这种算法没有新的思想，只是根据对象存活周期的不同将内存划分为几块，一般把Java堆分为新生代和老年代，这杨可以根据各个年代的特点采用最适当的
        收集算法，在新生代中，每次垃圾回收都有大批对象死去，少量存活，选用复制算法，老年代中对象存活较高，没有额外的空间担保，必须使用 标记-清理或者标记-整理算法


HotSpot的算法实现
    1，枚举根节点
    2，安全点
    3，安全区域

垃圾回收器
    如果说收集算法是内存回收的方法论，那么垃圾收集器就是内存回收的具体实现，Java虚拟机规范中对垃圾收集器应该如何实现并没有任何规定。并且一般都会提供参数供用户根据自己的应用特点和要求
    组合出各个年代所使用的收集器。虽然我们是在对各个收集器进行比较，但并非为了挑选出一个最好的收集器，因为直到到现在为止还没有最好的收集器出现，更加没有万能的收集器，所以我们选择的只是
    对具体应用最适合的收集器。

1，Serial收集器
    一个单线程收集器，他在收集垃圾时，必须暂停其他所有工作线程，直到收集结束。但是它简单高效，serial收集器对于运行在client模式下的虚拟机来说是一个很好的选择
    新生代采用复制算法，老年代采取标记-整理算法，暂停所有用户线程
2，ParNew收集器
    是serial的多线程版本，除了使用多线程进行垃圾收集之外，其余行为包括serial收集器可以的所有控制参数，收集算法，stop the world，对象分配规则，回收策略等都和serial收集器完全一样
    但它却是运行在server模式下的虚拟机中首选的新生代收集器，除了serial收集器外，只有他能与CMS收集器配合工作。ParNew收集器在单个CPU的环境中绝对不会比serial收集器更好的效果，甚至由于
    存在线程开销，该收集器在通过超线程技术实现的两个CPU的环境中不能百分百的保证可以超过seri收集器，随着可以使用的CPU的数量的增加，他对于GC时系统资源的有效利用还是很有好处的。
    新生代采取复制算法，老年代采用标记-整理算法，暂停所有用户线程
3，Parallel Scavenge收集器
    一个新生代收集器，他也使用复制算法的收集器，又是并行的多线程收集器。特点是他的关注点与其他收集器不同，CMS收集器关注点是尽可能缩短垃圾收集时用户线程的停顿时间，而ps收集器的目的
    是达到一个可控制的吞吐量，所谓吞吐量就是CPU用于运行用户代码的时间与CPU总消耗时间的比值，即吞吐量 = 运行用户代码时间/(运行用户代码时间+垃圾收集时间)
    停顿的时间越短越适合需要与用户交互的程序，良好的响应速度能提升用户体验，而高吞吐量则可以高效率的利用CPU时间，尽快的完成运算任务，主要适合在后台运算而不要太多交互的任务
    虚拟机会根据当前系统的运行情况收集性能监控信息，动态的调整这些参数已提供最合适的停顿时间或者最大的吞吐量，这种调节方式称为GC自适应的调节策略
4，Serial Old收集器
    是serial的老年版本，也是一个单线程收集器，使用标记-整理算法，用于client模式下的虚拟机使用，在server模式下有两大用途
    1，jdk1.5前搭配parallel scavenge收集器使用  2，作为CMS收集器的后备预案.新生代采取复制算法，老年代采取标记-整理算法，暂停所有用户线程
5，Parallel Old收集器
    是Parallel Old的老年版本，使用多线程和标记-整理算法，JDK1.6才开始提供
6，CMS收集器
    一种以获取最短回收停顿时间为目标的收集器，目前很大一部分的Java应用集中在互联网或者B/S系统的服务端上，这类服务重视响应速度，希望停顿时间短，CMS非常符合
    CMS收集器是基于 标记-清除算法实现的，运作过程相对于前面几种收集器复杂一些，分为4个步骤
    a,初始标记
    b,并发标记
    c,重新标记
    d,并发清除
    初始标记，重新标记需要Stop the world 初始标记只是标记一下GC Roots能直接关联的对象，速度很快
    并发标记阶段就是进行GC Roots Tracing的过程
    重新标记阶段则是为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段稍长一些，但远比并发标记时间短
    由于整个过程中耗时最长的并发标记和并发清除过程收集器都可以与用户线程一起工作，所以总体上，CMS收集器的内存回收过程是与用户线程一起执行并发的
    缺点
    a,CMS收集器对CPU资源非常敏感，其实，面向并发设计的程序都对CPU资源敏感，在并发阶段，不会导致用户线程停顿，但是会因为占用了一部分线程而导致程序变慢，总吞吐降低
      CMS的默认启动回收线程是（CPU数量+3）/4
    b,CMS收集器无法处理浮动垃圾，可能出现 Concurrent Mode failure失败，导致另外一次Full GC ，由于CMS并发清理用户线程还在，会产生新的垃圾，这部分垃圾标记过后，CMS无法集中处理他们
      只好等待下一次GC在清理，这一部分就是浮动垃圾。JDK1.6中 CMS收集的启动阈值提升至92%
    c,CMS 是一个标记-清除算法实现的，会有大量空间碎片产生。会给分配大对象带来麻烦。不得不提前出发FUll GC
7，G1收集器
    a,并发与并行
        G1充分利用多CPU，多环境下的硬件优势，缩短stop the world的时间，部分其他收集器原本需要停顿Java线程执行的GC动作，G1收集器任然可以通过并发的方式让Java程序继续执行
    b,分代收集
        与其他收集器一样，分代收集的概念在G1中依然保留，不需要配合其他收集器就能独立管理整个GC堆
    c,空间整合
        与CMS的 标记-清理算法不同，G1从整体来看是基于 标记-整理 算法的收集器，从局部上看来是基于 复制 算法实现，这两种算法意味着G1运作期间不会产生空间碎片，收集后能提供
        规整的可用内存，这种特性有利于程序长时间运行，分配大对象时不会因为无法找到连续内存空间提前触发下一次GC
    d,可预测的停顿
        这是G1相对于CMS的另外一大优势，降低停顿时间是G1和CMS共同关注点，但G1除了追求停顿时间外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为M毫秒的时间片段内
        消耗在垃圾收集上的时间不得超过N毫秒，这几乎是实时Java的垃圾收集的特征了
     在G1之前其他的收集器进行收集的范围都是整个新生代或者老年代，而G1不再是这样，G1收集时，Java堆的内存布局就与其他收集器有很大差别，他将整个Java堆划分为多个大小相等的独立区域
     虽然还保留有新生代和老年代的概念，但新生代和老年代不在是物理隔离，他们是一部分的Region的集合
     G1收集器之所以能建立可预测的停顿时间模型，是因为他可以有计划的避免在整个Java堆中进行全区域的垃圾回收，G1跟踪各个Region里面的垃圾堆积的价值大小，在后台维护一个优先列表，每次
     根据允许的收集时间，优先回收价值最大的Region，这种使用Region划分内存空间以及优先级的区域回收方式，保证了G1收集器在有限的时间竟可能高的效率
     G1收集器的运作大致可以分为以下几个步骤
        1，初始标记
        2，并发标记
        3，最终标记
        4，筛选回收

    理解GC日志
        GC日志的开头的 时间代表GC发生的时间，含义是从Java虚拟机启动以来经过的秒数
        开头的 GC和 Full GC 说明了垃圾收集的停顿类型，而不是用来区分新生代GC和老年代GC的，如果有Full 代表这次GC发生了stop-the-world
        [ DefNew [Tenured [Perm 表示GC发生的区域
        3324K->152K（3713K）含义是 GC前该区域已使用容量-> GC后该内存区域已使用容量（该内存区域总容量）
        3324K->152K(11904K) 表示GC前Java堆已使用容量->GC后Java堆已使用容量（Java堆总容量）
        后面的0.00000023442secs 表示内存区域GC所占的时间，单位是s

内存分配和回收策略
    1，对象优先在Eden分配
        对象在新生代Eden区中分配，当Eden没有足够的区域时，虚拟机发起一次Minor GC
    2，大对象直接进入老年代
        大对象是指大量连续内存空间的Java对象，典型的是那种很长的字符串以及数组
    3，长期存活的对象将进入老年代
        虚拟机给没个对象定义一个对象年龄计数器，年纪增加到15岁，会被晋升到老年代中
    4，动态对象年龄判定
        survivor空间中的相同年龄对象大小的总和大于survivor空间的一半，可以直接进入老年代，无须等到要求年龄
    5，空间分配担保
        在发生Minor GC之前，虚拟机会检查老年代最大可用空间的连续空间是否大于新生代对象总空间，如果成立GC可以确保安全，失败会查看是否允许担保失败，允许会继续检查老年代最大可用连续空间
        是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试进行一次Minor GC 小与则进行一次Full GC

jps 虚拟机进程状态工具
jstat 虚拟机统计信息监视工具
jinfo Java配置信息工具
jmap java内存映射工具
jhat 虚拟机堆转储快照分析工具
jstack Java堆栈跟踪工具
hsdis jit生成代码反汇编



类加载的时机
    类从加载到虚拟机内存中开始，到卸载出内存为止，他的整个生命周期包括：  其中验证，准备，解析3个部分称为连接
        加载（Loading）-->验证（Verification）-->准备（Preparation）-->解析（Resolution）
                                                                        |
                                                                        |
                     卸载（Unloading）<-- 使用（Using） <--初始化（Initialization）

    什么情况下需要开始类加载过程的第一个阶段，Java虚拟机没有进行强制约束，对于初始化阶段，虚拟机规范是严格规定了有且只有5种情况必须立即对类进行 初始化（而加载，验证，准备自然需要再此之前）
    1，遇到new,getstatic,putstatic,invokestatic这4个字节码指令时，如果类没有初始化，则需要先触发其初始化，生成这4条指令最常见的Java代码场景是：
        使用new关键字实例化对象的时候，读取或者设置一个类的静态字段，调用一个类的静态方法的时候
    2，使用java.lang.reflect包的方法对类进行反射调用的时候，如果类没有初始化，需要触发其初始化
    3，当初始化一个类的时候，如果发现其父类还没有进行初始化，则需要触发其父类初始化
    4，当虚拟机启动的时候，用户需要一个执行的主类（包含main方法的类），虚拟机会初始化这个类
    5，JDK1.7,如果一个java.lang.invoke.MethodHandle实例最后的解析结果REF_getstatic的方法句柄，并且这个方法句柄对应的类没有进行初始化，则需要触发其初始化

类的加载过程
    加载
        加载 是 类加载 过程的一个阶段，在加载阶段，虚拟机需要完成以下3件事
        1，通过一个类的全限定名来获取此类的二进制字节流
        2，将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构
        3，在内存中生成一个代表这个类的Java.lang.Class对象，作为方法区这个类的各种数据的访问入口

    验证
        验证是连接阶段的第一步，这一阶段的目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全
            1，文件格式验证
            2，元数据验证
            3，字节码验证
            4，符号引用验证

    准备
        准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些变量所使用的内存都将在方法区中进行分配，这个时候进行内存分配的仅包括类变量（被static修饰的变量）
        而不包括实例变量，实例变量将会在对象实例化时随着对象一起分配在Java堆中，其次，这里说的初始值，通常情况下是数据类型的零值。

     解析
        解析阶段是虚拟机将常量池的符号引用替换为直接引用的过程，解析动作主要针对类或者接口，字段，类方法，接口方法，方法类型，方法句柄和调用点限定符7类符号引用进行

    初始化
        类初始化阶段是类加载过程的最后一步，前面的类加载过程中，除了在加载阶段用户应用程序可以通过自定义类加载器参与之外，其余动作完全有虚拟机主导和控制，到了初始化阶段
        才算开始执行类中定义的Java程序代码
        在准备阶段，变量已经赋过一次系统要求的初始值，而在初始化阶段，根据程序员通过程序制定的主观计划去初始化类变量和其他资源

类加载器
    虚拟机团队把类加载阶段中的 通过一个类的全限定名来获取描述此类的二进制字节流  这个动作放到Java虚拟机外部实现，以便让应用程序自己决定如何去获取所需要的类，实现这个动作
    的代码块称为  类加载器

    类与类的加载器
        类加载器虽然只用于实现类的加载动作，但它在Java程序中起到的作用却远远不限于类加载阶段，对于任意一个类，都需要由加载它的类加载器和这个类本身一同确立其在Java虚拟机
        的唯一性，每一个类加载器，都拥有一个独立的类名空间，通俗的说：比较两个类是否“相等”只有在这两个类是由同一个类加载器加载的前提下才有意义，否则，即使这两个类来源于
        同一个class文件，被同一个虚拟机加载，只要加载他们的类加载器不同，这两个类就必定不相等，这里的“相等” 包括代表类的class对象的equals方法，isAssignableFrom()，isInstance()
        方法返回的结果，也包括instanceof关键字做对象所属关系判定情况
    双亲委派模型
        从Java虚拟机的角度来看，只存在两种不同的类加载器：一种是启动类加载器（Bootstrap ClassLoader） 这个类加载器是C++实现的，是虚拟机的一部分，另外一个就是所有其他的类加载器
        这类加载器都有Java语言来实现，独立于虚拟机外部，并且全都继承自抽象类java.lang.ClassLoader
        从Java开发人员的角度看，类加载器还可以划分更细致一些，绝大部分Java程序都会使用到以下3种系统提供的类加载器
            1，启动类加载器(Bootstrap ClassLoader) :
                <JAVA_HOME>\lib 目录中的，并且是虚拟机识别的类库加载到虚拟机中，启动类加载器无法被Java程序直接引用，用户在
                编写自定义类加载器时，如果需要把加载请求委派给引导类加载器，那直接使用null代替即可
            2，扩展类加载器：
                这个加载器由sun.misc.Launcher$ExtClassLoader实现，他负责加载<JAVA_HOME>\lib\ext目录中，或者被java.ext.dirs系统变量所指定的路径中的所有类库，开发者可以直接
                使用扩展类加载器
            3，应用程序类加载器：
                这个类加载器由sun.mic.Launcher$App-ClassLoader实现，由于这个类加载器是ClassLoader中的getSystemClassLoader()方法的返回值，所以一般也称为它为系统类加载器
                他负责加载用户路径（ClassPath）上所指定的类库，开发者可以直接使用这个类加载器，一般情况下这个就是程序中默认的类加载器


                启动类加载器（Bootstrap ClassLoader）
                            |
                扩展类加载器（Extension ClassLoader）
                            |
                应用程序类加载器(Application ClassLoader)
                    /                       \
       自定义类加载器                     自定义类加载器
       User ClassLoader                    User ClassLoader

       上面这种层次关系，称为类加载器的双亲委派模型（Parents Delegation Model）,双亲委派模型要求除了顶层的启动类加载器外，其余的类加载器都应有自己的父类加载器，这里类加载器之间的父子关系
       一般不会以继承的关系实现，而是使用组合关系来复用父加载器的代码

       双亲委派模型的工作过程是：如果一个类加载器收到了类加载的请求，他首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求
       最终都应该传送到顶层的启动类加载器中，只有父类加载器反馈自己无法完成这个加载请求时，子加载器才会尝试自己去加载

       使用的好处是 Java类随着类加载器一起具备了一种带有优先级的层次关系，例如类java.lang,Object 他存放在rt.jar中，无论那一个类加载器要加载这个类，最终都是委派给处于模型最顶端的启动类
       加载器进行加载，因此Object类在程序的各种类加载器环境中都是同一个类，相反，没有双亲委派，由各个类加载器自行去加载，如果用户自己编写一个Object放到ClassPath中，那么系统会出现两个不
       同的Object，Java类型中最基础的行为也就无法保证。实现双亲委派的代码都在java.lang.ClassLoader的loadClass()中，先检查是否已经被加载过，没有加载则调用父类加载器loadClass()方法
       若父类加载器为空则默认使用启动类加载器作为父加载器，如果父类加载失败，抛出ClassNotFoundException 再掉自己的findClass()方法加载

    破坏双亲委派模型

Major GC 是清理老年代。
Full GC 是清理整个堆空间—包括年轻代和老年代

堆参数
    -Xms 设置JVM启动时堆内存的初始大小
    -Xmx 设置堆内存最大值
    -Xmn 设置年轻代的空间大小，剩下的是老年代的空间大小
    -XX: PermGen 设置永久代内存的初始化大小 JDK1.8废弃了永久代
    -XX: MaxPermGen 设置永久代的最大值
    -XX: SurviorRatio 设置Eden和Survivor的空间比例
    -XX: NewRatio 设置年老代和年轻代的比例大小 默认是2

    整个JVM的内存大小 = 年轻代大小 + 年老代大小 + 持久代大小

回收器参数
    -XX: +UseSerialGC 串行，young和old都使用串行，使用复制算法回收，逻辑简单高效，无线程切换开销
    -XX：+UserParallelGC 并行 young区 使用 Parallel scavenge 回收算法，会产生多个线程并行回收，
    -XX：+UserParallelOldGC 并行，和UserParallelGC一样，young和old 的垃圾回收时使用多线程收集
    -XX：+UserConcMarkSweepGC 并发，短暂停顿的并发的收集，young：可以使用普通的或者parallel垃圾回收算法，由参数-XX：+UserParNewGC 来控制，Old区：只能使用Concurrent Mark Sweep
    -XX：+UseG1GC  并发的，并发的和增量式压缩短暂停顿的垃圾收集器，不区分young和old，它把堆空间划分多个大小相等的区域，当执行垃圾回收时，它会优先收集存活对象较少的区域 叫做Garbage First

垃圾回收统计信息
    -XX：+PrintGC
    -XX: +PrintGCDetails
    -XX: +PrintGCTimeStamps
    -Xloggc:filename

并行收集设置
    -XX：ParallelGCThreads = n 设置并行收集器收集时使用的CPU数，并行收集线程数
    -XX：MaxGCPauseMillis = n 设置并行收集最大暂停时间
    -XX：GCTimeRatio = n 设置垃圾回收时间占程序运行时间的百分比 公式为1（1+n）

并发收集器设置
    -XX：CMSIncrementalMode: 设置为增量模式 适用于单CPU情况
    -XX: ParallelGCThreads = n 设置并发收集器年轻代收集方式为并发收集时，使用的CPU树，并行收集线程数


jvm配置
-Xms 4800m                              初始化堆空间大小
-Xmx 4800m                              最大堆空间大小
-Xmn 1800m                              年轻代空间大小
-Xss 512K                               设置线程空间大小
-XX:PermSize=256m                       永久区大小（JDK1.8废除）
-XX:MaxPermSize=256m                    最大永久区空间大小
-XX:UseStringCache                      默认开启，启用缓存常用的字符串
-XX:UseConcMarkSweepGC                  老年代使用CMS收集器
-XX:UseParNewGC                         新生代使用并行收集器
-XX:ParallelGCThreads = 4               并行线程数量 4
-XX:+CMSClassUnloadingEnablcd           允许对类的元数据进行清理
XX:+DisableExplicitGC                   禁止显示的GC
-XX:+UseCMSInitiatingOccupancyOnly      表示只有达到阈值的之后才进行CMS回收
-XX:CMSInitiatingOccupancyFraction=68   设置CMS在老年代回收的阈值为68%
-verbosc:gc                             输出虚拟机GC详情
-XX:+PrintGCDetails                     打印GC详情日志
-XX:+PrintGCDateStamps                  打印GC的耗时
-XX:+PrintTenuringDistribution          打印Tenuring年龄信息
-XX:HeapDumpOnOutOfMemoryError          当抛出OOM时进行HeapDump
-XX:HeapDumpPath=/home/admin/logs       指定HeapDump的文件路劲


常用组合
Young                             Old                             JVM Options

Serial                            Serial                          -XX:+UseSerialGC

Parallel scavenge                 Parallel Old/Serial             -XX:+UserParallelGC
                                                                  -XX:+UserParallelOldGC

Serial/Parallel scavenge          CMS                             -XX:+UserParNewGC
                                                                  -XX:+UserConcMarkSweepGC

G1                                                                -XX:+UserG1GC


Minor GC：回收新生代上，因为新生代对象存活时间很短，因此 Minor GC 会频繁执行，执行的速度一般也会比较快。

Full GC：回收老年代和新生代，老年代对象其存活时间长，因此 Full GC 很少执行，执行速度会比 Minor GC 慢很多。


GC调优的目的
    1，将转移到老年代的对象数量降到最小
    2，减少GC的执行时间

    策略1：将新对象预留在新生代，由于 Full GC 的成本远高于 Minor GC，因此尽可能将对象分配在新生代是明智的做法，实际项目中根据 GC 日志分析新生代空间大小分配是否合理，
           适当通过“-Xmn”命令调节新生代大小，最大限度降低新对象直接进入老年代的情况。

    策略 2：大对象进入老年代，虽然大部分情况下，将对象分配在新生代是合理的。但是对于大对象这种做法却值得商榷，
            大对象如果首次在新生代分配可能会出现空间不足导致很多年龄不够的小对象被分配的老年代，破坏新生代的对象结构，可能会出现频繁的 full gc。
            因此，对于大对象，可以设置直接进入老年代（当然短命的大对象对于垃圾回收老说简直就是噩梦）。-XX:PretenureSizeThreshold 可以设置直接进入老年代的对象大小。

    策略 3：合理设置进入老年代对象的年龄，-XX:MaxTenuringThreshold 设置对象进入老年代的年龄大小，减少老年代的内存占用，降低 full gc 发生的频率。

    策略 4：设置稳定的堆大小，堆大小设置有两个参数：-Xms 初始化堆大小，-Xmx 最大堆大小。

    策略5：注意：如果满足下面的指标，则一般不需要进行 GC 优化：
            MinorGC 执行时间不到50ms；
            Minor GC 执行不频繁，约10秒一次；
            Full GC 执行时间不到1s；
            Full GC 执行频率不算频繁，不低于10分钟1次。


什么时候触发MinorGC?什么时候触发FullGC?
     虚拟机在进行minorGC之前会判断老年代最大的可用连续空间是否大于新生代的所有对象总空间
         1、如果大于的话，直接执行minorGC
         2、如果小于，判断是否开启HandlerPromotionFailure，没有开启直接FullGC
         3、如果开启了HanlerPromotionFailure, JVM会判断老年代的最大连续内存空间是否大于历次晋升的大小，如果小于直接执行FullGC
         4、如果大于的话，执行minorGC

     触发FullGC
          老年代空间不足
               如果创建一个大对象，Eden区域当中放不下这个大对象，会直接保存在老年代当中，如果老年代空间也不足，就会触发Full GC。为了避免这种情况，最好就是不要创建太大的对象。
          持久代空间不足
              如果有持久代空间的话，系统当中需要加载的类，调用的方法很多，同时持久代当中没有足够的空间，就出触发一次Full GC
          YGC出现promotion failure
              promotion failure发生在Young GC, 如果Survivor区当中存活对象的年龄达到了设定值，会就将Survivor区当中的对象拷贝到老年代，如果老年代的空间不足，就会发生promotion failure， 接下去就会发生Full GC.
          统计YGC发生时晋升到老年代的平均总大小大于老年代的空闲空间
                在发生YGC是会判断，是否安全，这里的安全指的是，当前老年代空间可以容纳YGC晋升的对象的平均大小，如果不安全，就不会执行YGC,转而执行Full GC。
          显示调用System.gc