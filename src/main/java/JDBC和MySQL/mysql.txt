ACID
    原子性（Atomicity）

        事务的原子性是指事务必须是一个原子的操作序列单元，事务中包含的各项操作在一次执行过程中，只允许出现以下两种状态之一
            1，全部成功执行
            2，全部不执行
         任何一项操作失败都将导致整个事务失败，同时其他已经被执行的操作都将被撤销并回滚，只有所有的操作全部成功，整个事务才算成功

    一致性（Consistency）

        事务的一致性是指事务的执行不能破坏数据库的完整性和一致性，一个事务在执行之前和执行之后，数据库都必须处于一致性状态。

    隔离性（Isolation）

        事务的隔离性是指在并发环境中，并发的事务是相互隔离的，一个事务的执行不能被其他事务干扰，也就是说，不同的事务并发操作相同的数据时，每个是事务都是各自完整的数据空间。
        即一个事务内部的操作及使用的数据对其他并发事务是隔离的，并发执行的各个事务之间不能互相干扰

        4个隔离级别
            1，未授权读取（Read Uncommitted） 读未提交，该隔离级别允许脏读取，其隔离级别最低，换句话说，如果一个事务正在处理某一数据，并对其进行更新，但同时尚未完成事务，因此
            还没有进行事务提交，而与此同时，允许另一个事务也能够访问数据。事务A执行过程阶段，事务B能够看到事务A操作过程中的所有中间值

            2，授权读取（Read Committed） 未授权读取非常相近，唯一的区别是授权读取只允许获取已经被提交的数据。事务A操作的中间值，事务B是无法看到的，只能看到最终值

            3，可重复读取（Repeatable Read） 保证在事务处理过程中，多次读取同一个数据时，其值都和事务开始时刻是一致的，因此该事务级别禁止了不可重复读取和脏读取，但是有可能出现幻影数据
               幻影数据指同样的事务操作，在前后两个时间段内执行对同一个数据项的读取，可能出现不一致的结果

            4，串行化（Serializable）是最严格的事务隔离级别，它要求所有事务都被串行执行，即事务只能一个接一个的进行处理，不能并发执行

            隔离级别                脏读                                         可重复读                           幻读
            未授权读取             存在                                            不可以                             存在
            授权读取               不存在                                          不可以                             存在
            可重复读取             不存在                                          可以                               存在
            串行化                 不存在                                          可以                              不存在

       1、脏读：事务A读取了事务B更新的数据，然后B回滚操作，那么A读取到的数据是脏数据

       2、不可重复读：事务 A 多次读取同一数据，事务 B 在事务A多次读取的过程中，对数据作了更新并提交，导致事务A多次读取同一数据时，结果 不一致。

       3、幻读：系统管理员A将数据库中所有学生的成绩从具体分数改为ABCDE等级，但是系统管理员B就在这个时候插入了一条具体分数的记录，当系统管理员A改结束后发现还有一条记录没有改过来，
          就好像发生了幻觉一样，这就叫幻读。

    持久性（Durability）

        事务的持久性也被称为永久性，是指一个事务一旦提交，它对数据库中对应数据的状态变更就应该是永久性的，换句话说，一旦某个事务成功结束，那么他对数据库所做的更新就必须被永久保存下来


数据库的锁（行锁，表锁，页级锁，意向锁，读锁，写锁，悲观锁，乐观锁）
    表级锁（锁定整个表）
    页级锁（锁定一页）  BDB引擎
    行级锁（锁定一行）

MyISAM
        表共享读锁 （Table Read Lock）：不会阻塞其他用户对同一表的读请求，但会阻塞对同一表的写请求；
        表独占写锁 （Table Write Lock）：会阻塞其他用户对同一表的读和写操作；

        MyISAM 在执行查询语句（SELECT）前，会自动给涉及的表加读锁，在执行更新操作
        （UPDATE、DELETE、INSERT 等）前，会自动给涉及的表加写锁，这个过程并不需要用户干预，因此，用户一般不需要直接用 LOCK TABLE 命令给 MyISAM 表显式加锁。

    InnoDB
        InnoDB 实现了以下两种类型的行锁：
            共享锁（S）：允许一个事务去读一行，阻止其他事务获得相同数据集的排他锁。
            排他锁（X）：允许获得排他锁的事务更新数据，阻止其他事务取得相同数据集的共享读锁和排他写锁。

        为了允许行锁和表锁共存，实现多粒度锁机制，InnoDB 还有两种内部使用的意向锁（Intention Locks），这两种意向锁都是表锁：
            意向共享锁（IS）：事务打算给数据行加行共享锁，事务在给一个数据行加共享锁前必须先取得该表的 IS 锁。
            意向排他锁（IX）：事务打算给数据行加行排他锁，事务在给一个数据行加排他锁前必须先取得该表的 IX 锁。

        InnoDB加锁方法
            1，意向锁是 InnoDB 自动加的， 不需用户干预。
            2，对于 UPDATE、 DELETE 和 INSERT 语句， InnoDB
               会自动给涉及数据集加排他锁（X)；
            3，对于普通 SELECT 语句，InnoDB 不会加任何锁；
            事务可以通过以下语句显式给记录集加共享锁或排他锁：
                共享锁（S）：SELECT * FROM table_name WHERE ... LOCK IN SHARE MODE。 其他 session 仍然可以查询记录，并也可以对该记录加 share mode 的共享锁。
                但是如果当前事务需要对该记录进行更新操作，则很有可能造成死锁。
                排他锁（X)：SELECT * FROM table_name WHERE ... FOR UPDATE。其他 session 可以查询该记录，但是不能对该记录加共享锁或排他锁，而是等待获得锁

        隐式锁定
            InnoDB在事务执行过程中，使用两阶段锁协议：
            随时都可以执行锁定，InnoDB会根据隔离级别在需要的时候自动加锁；
            锁只有在执行commit或者rollback的时候才会释放，并且所有的锁都是在同一时刻被释放


        InnoDB 行锁实现方式：
            1，InnoDB 行锁是通过给索引上的索引项加锁来实现的，这一点 MySQL 与 Oracle 不同，后者是通过在数据块中对相应数据行加锁来实现的。InnoDB 这种行锁实现特点意味着：只有通过索引条件检索数据，InnoDB 才使用行级锁，否则，InnoDB 将使用表锁！
            2，不论是使用主键索引、唯一索引或普通索引，InnoDB 都会使用行锁来对数据加锁。
            3，只有执行计划真正使用了索引，才能使用行锁：即便在条件中使用了索引字段，但是否使用索引来检索数据是由 MySQL 通过判断不同执行计划的代价来决定的，如果 MySQL 认为全表扫描效率更高，比如对一些很小的表，它就不会使用索引，这种情况下 InnoDB 将使用表锁，而不是行锁。因此，在分析锁冲突时，
               别忘了检查 SQL 的执行计划（可以通过 explain 检查 SQL 的执行计划），以确认是否真正使用了索引。（更多阅读：MySQL索引总结）
            4，由于 MySQL 的行锁是针对索引加的锁，不是针对记录加的锁，所以虽然多个session是访问不同行的记录， 但是如果是使用相同的索引键， 是会出现锁冲突的（后使用这些索引的session需要等待先使用索引的session释放锁后，才能获取锁）。 应用设计的时候要注意这一点。

    悲观锁（Pessimistic Concurrency Control，PCC）：假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作。至于怎么加锁，加锁的范围也没讲。
        悲观锁，顾名思义，就是很悲观，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会block直到它拿到锁。
        传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。

    乐观锁（Optimistic Concurrency Control，OCC）：假设不会发生并发冲突，只在提交操作时检查是否违反数据完整性。也没具体指定怎么检查。
        乐观锁, 顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，
        可以使用版本号等机制。乐观锁适用于多读的应用类型，这样可以提高吞吐量，像数据库如果提供类似于write_condition机制的其实都是提供的乐观锁。


    主从复制
        1，基于语句的复制
            主服务器上面执行的语句在从服务器上在执行一遍
            存在问题：时间上可能不完全同步造成偏差，执行语句的用户可能不是同一个用户
        2，基于行的复制
            把主服务器上面改编后的内容直接复制过去，而不关心到底是那条语句引发的
        3，混合复制
            默认基于语句，当基于语句的复制会引发问题的时候就会基于行复制，MySQL会自动进行选择
            读操作可以在所有的服务器上进行，而写操作只能在主服务器上进行

    读写分离
        1，应用层分离  访问数据库的时候配置多数据源，然后分流
        2，代理实现   在应用层和数据库集群之间添加一个代理服务器，应用层访问代理层，代理根据请求的类型自动分流到不同的数据库


数据库的三范式
    第一范式：确保每一列都是原子性的。即每个属性都是不可能再分的最小数据单元。
	第二范式：满足第一范式的基础上，非主键必须完全依赖主键，而且不是仅仅依赖主键的部分。
	    第二范式需要确保数据库表中的每一列都和主键相关，而不能只与主键的某一部分相关（主要针对联合主键而言）。也就是说在一个数据库表中，
	    一个表中只能保存一种数据，不可以把多种数据保存在同一张数据库表中
	第三范式：需要确保数据表中的每一列数据都和主键直接相关，而不能间接相关。



SQL的书写顺序
    select---from---where---group by---having---order by

SQl的执行顺序
    from---where---group by---having---select---order by

from :需要从哪个数据表检索数据
where:过滤表中数据
group by:将上面过滤出的数据分组
having：对上面已经分组的数据进行过滤
select：查看结果集中的列，或者列的计算结果
order by：按照什么样的顺序来查看返回的数据