1,程序计数器
    是一块较小的内存空间，可以看做是当前线程所执行的字节码的行号指示器。
    字节码解释器工作时就是通过改变这个计数器的值来取下一条需要执行的字节码指令，分支，循环，跳转，异常处理，线程恢复等基础功能都要依赖这个计数器

    由于Java虚拟机的多线程通过线程轮流分配处理器执行时间的方式来实现的，在任何一个确定的时刻，一个处理器都只会执行一条线程中的指令，因此，为了线程切换后能恢复到正确的执行位置
    每条线程需要一个独立的程序计数器，各线程之间的计数器互不影响，独立存储，我们称这类内存区域为 “线程私有” 的内存

    如果线程正在执行的是一个Java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址，如果正在执行的是Native方法，这个计数器值则为空.
    此内存区域是唯一一个在Java虚拟机中没有规定任何OutOfMemoryError情况的区域


2，Java虚拟栈
    和程序计数器一样，Java虚拟机栈也是线程私有的，他的生命周期与线程相同，虚拟机栈描述的是Java方法执行的内存模型，每个方法执行时都会创建一个栈帧
    用于存储局部变量表，操作数栈，动态链接，方法出口等信息，每一个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机中入栈到出栈的过程
    我们通常的 栈 就是现在的虚拟机栈，局部变量表存放了编译期可知的各种基本数据类型，对象引用，和returnAddress类型
    局部变量表所需的内存空间在编译期间完成分配，当进入一个方法时，这个方法需要在帧中分配多大的局部变量空间完全是确定的，在方法运行期间不会改变的
    这个区域规定两两种异常
        1，如果线程请求的栈深度大于虚拟机所允许的深度，抛出StackOverflowError异常
        2，如果虚拟机栈可以动态的扩展，如果扩展时无法申请到足够的内存，会抛出OutMemoryError


3,本地方法栈
    本地方法栈和虚拟机栈所发挥的作用是非常相似的，他们之间的区别不过是虚拟机栈为虚拟机执行Java方法服务，而本地方法栈则为虚拟机使用到的Native方法服务


4，Java堆
    对于大多数应用来说，Java堆是Java虚拟机所管理的内存中内存最大的一块。Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建，此区域唯一的目的就是存放对象实例
    几乎所有的对象实例都在这里分配内存
    Java堆是垃圾回收管理器的主要区域，因此很多时候也被称为 GC堆 从内存回收的角度来看，由于现在收集器基本采用分代收集算法，所以Java堆中可以细分为：新生代和老年代
    Java堆可以是物理上不连续的内存空间中，只要逻辑上是连续的即可，就像我们的磁盘空间一样。来实现时，即可以实现成固定大小的，也可以扩展的，现在主流都是可以扩展的
    （通过-Xmx和-Xms控制）如果堆中没有内存完成实例分配，并且堆也无法在扩展，会抛出OutOfMemoryError

5，方法区
    方法区与Java堆一样，在各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息，常量，静态变量，即时编译器编译后的代码数据，虽然Java虚拟机规范把方法区描述为堆
    的一个逻辑部分，但是它却有一个别名叫做Non-Heap（非堆） 目的是与Java堆区分开来  Java虚拟机规范对方法区的限制非常宽松，除了和Java堆一样不需要连续的内存和选择固定大小
    或者可扩展外，还可以选择不实现垃圾回收，相对而言，垃圾回收再这一区域比较少出现，这区域的内存回收目标主要是针对常量池的回收和对类型的卸载。

6，运行时常量池
    运行时常量池是方法区的一部分，class文件中除了有类的版本，字段，方法，接口等描述信息外，还有一项是常量池，用于存放编译期生成的各种字面量和符号引用，这部分内容在类加载后
    进入方法区的运行时常量池中存放
    Java虚拟机对class文件每一部分（包括常量池）的格式有着严格的规定，每一个字节用于存储哪种数据都必须符合规范上的要求才会被虚拟机认可，装载和执行，但对于运行时常量池，Java
    虚拟机规范没有做任何细节的要求

7，直接内存
    直接内存并不是虚拟机运行时数据区的一部分，也不是Java虚拟机规范中定义的内存区域，但这部分内存也被频繁使用，也可能导致OutOfMemoryError异常

主流的商用程序语言，通过可达性分析来判定对象是否存活的，这个算法的基本思想是通过一系列的称为GC Roots的对象作为起点，丛这些节点开始向下搜索，搜索所走过的路劲称为引用链
当一个对象到GC Roots没有任何引用链相连，则证明此对象是可也用的
在Java语言中，可作为GC Roots的对象包括下面几种
    虚拟机栈中的引用对象
    方法区中静态属性引用对象
    方法区中常量引用的对象
    本地方法栈中JNI（一般说的Native方法）引用的对象

1，强引用
    是指在程序代码之中普遍存在的，类似Object obl = new Object()这类的引用，只要加强引用还在，垃圾回收器永远不会回收掉被引用的对象

2，软引用
    用来描述一些还在用但并非必须的对象，对于软引用关联着的对象，在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围之中进行二次回收。
    如果这次回收还没有足够的内存，才会抛出内存溢出异常

3，弱引用
    用来描述非必须对象的，但他的强度比软引用更弱一些，被弱引用关联的对象只能存到下一次垃圾收集发生之前，当垃圾收集工作时，无论当前内存是否足够
    都会回收掉只被弱引用关联的对象

4，虚引用
    也被称为幽灵引用或者幻影引用，他是最弱的一种引用关系，一个对象是否有虚引用存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例
    为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系列通知。


回收方法区
    Java虚拟机规范中确实说过可以不要求虚拟机在方法区实现垃圾回收，而且在方法区中进行垃圾回收，性价比很低，在堆中，尤其是在新生代中，常规应用进行一次垃圾收集可以回收70%-95%的空间
    而永久代的垃圾收集效率远低于此。永久代的垃圾收集主要回收两部分内容：废弃常量和无用的类  回收废弃常量与回收Java堆中的对象非常类似
    类需要同时满足下面3个条件才能算是“无用的类”
    1，该类所有的实例都已经被回收，也就是Java堆中不存在该类的任何实例
    2，加载该类的classloader已经被回收
    3，该类对应的Java.lang.class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法
    虚拟机可以对满足上3个条件的无用类进行回收，这里说的仅仅是可以，而并不是和对象一样，不使用了就必然回收，是否对类回收，HotSpot虚拟机提供了-Xnoclassgc参数进行控制


垃圾回收算法
    1，标记-清楚算法
       最基础的收集算法是标记-清除算法，算法分为“标记"和”清除“两个阶段，首先标记处需要回收的对象，在标记完成后统一回收所有标记的对象。他的不足
       1，效率问题，标记和清除两个过程的效率都不高
       2，空间问题，标记清除后会产生大量的不连续的内存碎片，空间碎片太多可能会导致以后再程序运行过程中需要分配较大对象时，无法找到足够的连续内存而不得不提前触发垃圾收集动作

    2，复制算法
        为了解决效率问题，一种称为 复制 的收集算法出现了，它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块，当这一块的内存用完了，就将还存活着的对象复制到另外一块上
        然后把已经使用过的内存一次清理掉，这样内存分配时也就不用考虑内存碎片等复杂情况，这种算法代价是将内存缩小为了原来的一半
        现在的商业虚拟机都采用这种算法来回收新生代，新生代中的对象98%是朝生夕死，所以不需要按照1:1 分为 一块大的Eden和两块小的survivor空间。回收时将Eden和survivor中还存活的对象一次
        复制到另外一个survivor，清理掉Eden和survivor，HotSpot虚拟机默认的Eden和survivor的比例是8:1 ，也就是每次新生代中可使用内存空间为整个新生代容量的90%，当survivor空间不够时需要依赖
        其他内存（老年代）进行分配担保
        就好比我们去银行借款，98%都可以按时偿还，只需要一个担保人能在我们不能偿还的时候，可以从他的账户扣钱就可以了，内存的分配也是一样，如果survivor空间没有足够的内存存放上一次新生代收集
        下来存活对象时，这些对象直接通过分配担保机制进入老年代。

    3，标记-整理算法
        复制收集算法在对象存活率较高时会进行较多的复制操作，效率会变低，如果不想浪费50%的空间，就需要额外的空间进行分配担保，以应对内存中所有对象100%存活的极端情况，所以老年代一般不能直接
        用这种算法
        标记过程和标记清除算法一样，但后续步骤不是直接对可回收对象进行清理，而是让存活对象向一端移动，然后直接清理掉边界以外的内存

    4，分代收集算法
        当前的商业虚拟机都采用分代收集算法，这种算法没有新的思想，只是根据对象存活周期的不同将内存划分为几块，一般把Java堆分为新生代和老年代，这杨可以根据各个年代的特点采用最适当的
        收集算法，在新生代中，每次垃圾回收都有大批对象死去，少量存活，选用复制算法，老年代中对象存活较高，没有额外的空间担保，必须使用 标记-清理或者标记-整理算法


HotSpot的算法实现
    1，枚举根节点
    2，安全点
    3，安全区域

垃圾回收器
    如果说收集算法是内存回收的方法论，那么垃圾收集器就是内存回收的具体实现，Java虚拟机规范中对垃圾收集器应该如何实现并没有任何规定。并且一般都会提供参数供用户根据自己的应用特点和要求
    组合出各个年代所使用的收集器。虽然我们是在对各个收集器进行比较，但并非为了挑选出一个最好的收集器，因为直到到现在为止还没有最好的收集器出现，更加没有万能的收集器，所以我们选择的只是
    对具体应用最适合的收集器。

1，Serial收集器
    一个单线程收集器，他在收集垃圾时，必须暂停其他所有工作线程，直到收集结束。但是它简单高效，serial收集器对于运行在client模式下的虚拟机来说是一个很好的选择
    新生代采用复制算法，老年代采取标记-整理算法，暂停所有用户线程
2，ParNew收集器
    是serial的多线程版本，除了使用多线程进行垃圾收集之外，其余行为包括serial收集器可以的所有控制参数，收集算法，stop the world，对象分配规则，回收策略等都和serial收集器完全一样
    但它却是运行在server模式下的虚拟机中首选的新生代收集器，除了serial收集器外，只有他能与CMS收集器配合工作。ParNew收集器在单个CPU的环境中绝对不会比serial收集器更好的效果，甚至由于
    存在线程开销，该收集器在通过超线程技术实现的两个CPU的环境中不能百分百的保证可以超过seri收集器，随着可以使用的CPU的数量的增加，他对于GC时系统资源的有效利用还是很有好处的。
    新生代采取复制算法，老年代采用标记-整理算法，暂停所有用户线程
3，Parallel Scavenge收集器
    一个新生代收集器，他也使用复制算法的收集器，又是并行的多线程收集器。特点是他的关注点与其他收集器不同，CMS收集器关注点是尽可能缩短垃圾收集时用户线程的停顿时间，而ps收集器的目的
    是达到一个可控制的吞吐量，所谓吞吐量就是CPU用于运行用户代码的时间与CPU总消耗时间的比值，即吞吐量 = 运行用户代码时间/(运行用户代码时间+垃圾收集时间)
    停顿的时间越短越适合需要与用户交互的程序，良好的响应速度能提升用户体验，而高吞吐量则可以高效率的利用CPU时间，尽快的完成运算任务，主要适合在后台运算而不要太多交互的任务
    虚拟机会根据当前系统的运行情况收集性能监控信息，动态的调整这些参数已提供最合适的停顿时间或者最大的吞吐量，这种调节方式称为GC自适应的调节策略
4，Serial Old收集器
    是serial的老年版本，也是一个单线程收集器，使用标记-整理算法，用于client模式下的虚拟机使用，在server模式下有两大用途
    1，jdk1.5前搭配parallel scavenge收集器使用  2，作为CMS收集器的后备预案.新生代采取复制算法，老年代采取标记-整理算法，暂停所有用户线程
5，Parallel Old收集器
    是Parallel Old的老年版本，使用多线程和标记-整理算法，JDK1.6才开始提供
6，CMS收集器
    一种以获取最短回收停顿时间为目标的收集器，目前很大一部分的Java应用集中在互联网或者B/S系统的服务端上，这类服务重视响应速度，希望停顿时间短，CMS非常符合
    CMS收集器是基于 标记-清除算法实现的，运作过程相对于前面几种收集器复杂一些，分为4个步骤
    a,初始标记
    b,并发标记
    c,重新标记
    d,并发清除
    初始标记，重新标记需要Stop the world 初始标记只是标记一下GC Roots能直接关联的对象，速度很快
    并发标记阶段就是进行GC Roots Tracing的过程
    重新标记阶段则是为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段稍长一些，但远比并发标记时间短
    由于整个过程中耗时最长的并发标记和并发清除过程收集器都可以与用户线程一起工作，所以总体上，CMS收集器的内存回收过程是与用户线程一起执行并发的
    缺点
    a,CMS收集器对CPU资源非常敏感，其实，面向并发设计的程序都对CPU资源敏感，在并发阶段，不会导致用户线程停顿，但是会因为占用了一部分线程而导致程序变慢，总吞吐降低
      CMS的默认启动回收线程是（CPU数量+3）/4
    b,CMS收集器无法处理浮动垃圾，可能出现 Concurrent Mode failure失败，导致另外一次Full GC ，由于CMS并发清理用户线程还在，会产生新的垃圾，这部分垃圾标记过后，CMS无法集中处理他们
      只好等待下一次GC在清理，这一部分就是浮动垃圾。JDK1.6中 CMS收集的启动阈值提升至92%
    c,CMS 是一个标记-清除算法实现的，会有大量空间碎片产生。会给分配大对象带来麻烦。不得不提前出发FUll GC
7，G1收集器
    a,并发与并行
        G1充分利用多CPU，多环境下的硬件优势，缩短stop the world的时间，部分其他收集器原本需要停顿Java线程执行的GC动作，G1收集器任然可以通过并发的方式让Java程序继续执行
    b,分代收集
        与其他收集器一样，分代收集的概念在G1中依然保留，不需要配合其他收集器就能独立管理整个GC堆
    c,空间整合
        与CMS的 标记-清理算法不同，G1从整体来看是基于 标记-整理 算法的收集器，从局部上看来是基于 复制 算法实现，这两种算法意味着G1运作期间不会产生空间碎片，收集后能提供
        规整的可用内存，这种特性有利于程序长时间运行，分配大对象时不会因为无法找到连续内存空间提前触发下一次GC
    d,可预测的停顿
        这是G1相对于CMS的另外一大优势，降低停顿时间是G1和CMS共同关注点，但G1除了追求停顿时间外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为M毫秒的时间片段内
        消耗在垃圾收集上的时间不得超过N毫秒，这几乎是实时Java的垃圾收集的特征了
     在G1之前其他的收集器进行收集的范围都是整个新生代或者老年代，而G1不再是这样，G1收集时，Java堆的内存布局就与其他收集器有很大差别，他将整个Java堆划分为多个大小相等的独立区域
     虽然还保留有新生代和老年代的概念，但新生代和老年代不在是物理隔离，他们是一部分的Region的集合
     G1收集器之所以能建立可预测的停顿时间模型，是因为他可以有计划的避免在整个Java堆中进行全区域的垃圾回收，G1跟踪各个Region里面的垃圾堆积的价值大小，在后台维护一个优先列表，每次
     根据允许的收集时间，优先回收价值最大的Region，这种使用Region划分内存空间以及优先级的区域回收方式，保证了G1收集器在有限的时间竟可能高的效率
     G1收集器的运作大致可以分为以下几个步骤
        1，初始标记
        2，并发标记
        3，最终标记
        4，筛选回收

    理解GC日志
        GC日志的开头的 时间代表GC发生的时间，含义是从Java虚拟机启动以来经过的秒数
        开头的 GC和 Full GC 说明了垃圾收集的停顿类型，而不是用来区分新生代GC和老年代GC的，如果有Full 代表这次GC发生了stop-the-world
        [ DefNew [Tenured [Perm 表示GC发生的区域
        3324K->152K（3713K）含义是 GC前该区域已使用容量-> GC后该内存区域已使用容量（该内存区域总容量）
        3324K->152K(11904K) 表示GC前Java堆已使用容量->GC后Java堆已使用容量（Java堆总容量）
        后面的0.00000023442secs 表示内存区域GC所占的时间，单位是s

内存分配和回收策略
    1，对象优先在Eden分配
        对象在新生代Eden区中分配，当Eden没有足够的区域时，虚拟机发起一次Minor GC
    2，大对象直接进入老年代
        大对象是指大量连续内存空间的Java对象，典型的是那种很长的字符串以及数组
    3，长期存活的对象将进入老年代
        虚拟机给没个对象定义一个对象年龄计数器，年纪增加到15岁，会被晋升到老年代中
    4，动态对象年龄判定
        survivor空间中的相同年龄对象大小的总和大于survivor空间的一半，可以直接进入老年代，无须等到要求年龄
    5，空间分配担保
        在发生Minor GC之前，虚拟机会检查老年代最大可用空间的连续空间是否大于新生代对象总空间，如果成立GC可以确保安全，失败会查看是否允许担保失败，允许会继续检查老年代最大可用连续空间
        是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试进行一次Minor GC 小与则进行一次Full GC

jps 虚拟机进程状态工具
jstat 虚拟机统计信息监视工具
jinfo Java配置信息工具
jmap java内存映射工具
jhat 虚拟机堆转储快照分析工具
jstack Java堆栈跟踪工具
hsdis jit生成代码反汇编








