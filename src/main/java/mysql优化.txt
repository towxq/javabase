1，开启慢查询日志，设置相应的阈值
2，explain分析慢查询SQL语句
3，show profile比explain更一步接近执行细节，知道每一个SQL都干了啥事，用了多长时间

explain分析效果
    1，ID
        ID相同执行顺序由上而下
        id不同，越大越先被执行
    2，select_type
         SIMPLE： 表示此查询不包含 UNION 查询或子查询
         PRIMARY： 表示此查询是最外层的查询
         SUBQUERY： 子查询中的第一个 SELECT
         UNION： 表示此查询是 UNION 的第二或随后的查询
         DEPENDENT UNION： UNION 中的第二个或后面的查询语句, 取决于外面的查询
         UNION RESULT, UNION 的结果
         DEPENDENT SUBQUERY: 子查询中的第一个 SELECT, 取决于外面的查询. 即子查询依赖于外层查询的结果.
         DERIVED：衍生，表示导出表的SELECT（FROM子句的子查询）
    3,table
        查询涉及的表
    4，type
         system: 表中只有一条数据， 这个类型是特殊的 const 类型。
         const:  针对主键或索引的等值查询扫描，最多只返回一行数据。 const 查询速度非常快， 因为它仅仅读取一次即可。例如下面的这个查询，它使用了主键索引，
                 因此 type 就是 const 类型的：explain select * from user_info where id = 2；
         eq_ref: 此类型通常出现在多表的 join 查询，表示对于前表的每一个结果，都只能匹配到后表的一行结果。并且查询的比较操作通常是 =，
                 查询效率较高。例如：explain select * from user_info, order_info where user_info.id = order_info.user_id;
         ref:    此类型通常出现在多表的 join 查询，针对于非或非主键索引，或者是使用了 最左前缀 规则索引的查询。
                 例如下面这个例子中， 就使用到了 ref 类型的查询：explain select * from user_info, order_info where user_info.id = order_info.user_id AND order_info.user_id = 5
        range: 表示使用索引范围查询，通过索引字段范围获取表中部分数据记录。这个类型通常出现在 =, <>, >, >=, <, <=, IS NULL, <=>, BETWEEN, IN() 操作中。
                例如下面的例子就是一个范围查询：explain select * from user_info where id between 2 and 8；
        index: 表示全索引扫描(full index scan)，和 ALL 类型类似，只不过 ALL 类型是全表扫描，而 index 类型则仅仅扫描所有的索引， 而不扫描数据。
                index 类型通常出现在：所要查询的数据直接在索引树中就可以获取到, 而不需要扫描数据。当是这种情况时，Extra 字段 会显示 Using index。
        ALL: 表示全表扫描，这个类型的查询是性能最差的查询之一。通常来说， 我们的查询不应该出现 ALL 类型的查询，因为这样的查询在数据量大的情况下，对数据库的性能是巨大的灾难。
              如一个查询是 ALL 类型查询， 那么一般来说可以对相应的字段添加索引来避免。

        通常来说, 不同的 type 类型的性能关系如下:
              ALL < index < range ~ index_merge < ref < eq_ref < const < system
        ALL 类型因为是全表扫描， 因此在相同的查询条件下，它是速度最慢的。而 index 类型的查询虽然不是全表扫描，但是它扫描了所有的索引，
        因此比 ALL 类型的稍快.后面的几种类型都是利用了索引来查  询数据，因此可以过滤部分或大部分数据，因此查询效率就比较高了。
    5,possible_key
        它表示 mysql 在查询时，可能使用到的索引。 注意，即使有些索引在 possible_keys 中出现，但是并不表示此索引会真正地被 mysql 使用到。
        mysql 在查询时具体使用了哪些索引，由 key 字段决定。

    6,key
        此字段是 mysql 在当前查询时所真正使用到的索引。
    7,key_len
        表示查询优化器使用了索引的字节数，这个字段可以评估组合索引是否完全被使用
    8,ref
        这个表示显示索引的哪一列被使用了，如果可能的话,是一个常量
    9,rows
        rows 也是一个重要的字段，mysql 查询优化器根据统计信息，估算 sql 要查找到结果集需要扫描读取的数据行数，这个值非常直观的显示 sql 效率好坏， 原则上 rows 越少越好
    10,extra
        explain 中的很多额外的信息会在 extra 字段显示, 常见的有以下几种内容:
        using filesort ：表示 mysql 需额外的排序操作，不能通过索引顺序达到排序效果。一般有 using filesort都建议优化去掉，因为这样的查询 cpu 资源消耗大。
        using index：覆盖索引扫描，表示查询在索引树中就可查找所需数据，不用扫描表数据文件，往往说明性能不错。
        using temporary：查询有使用临时表, 一般出现于排序， 分组和多表 join 的情况， 查询效率不高，建议优化。
        using where ：表名使用了where过滤。


那些情况需要创建索引
    1，主键建立唯一索引
    2，频繁的查询条件
    3，查询中与其他表关联的字段
    4，单键，组合索引的选择问题，组合索引性价比更高
    5，查询中的排序字段，排序字段若通过索引去访问将大大提高排序速度
    6，查询中统计或者分段字段

不需要创建索引
    1，表记录太少
    2，经常增删的表或者结构
    3，where用不到的字段
    4，过滤性不好的字段，如性别


1,单库表别太多，一般200以下
2，尽量避免SQL中出现预算，DB功能单一化
3，表设计精简，尽量小儿精
4，SQL事务不能太大
5，设计表尽量用小数据类型，避免text，blob
6，能用数字的别用字符
7，避免null字段
8，图片别存DB
9，大SQL做拆分，避免长时间的锁表
10，存储过程，触发器别用了，维护不方便
11，别用select *
12，update的条件走索引，避免全表扫描
13，or 别用，该 in
14，or 可以用union
15，%前缀 模糊查询，索引会失效
16，count(*)别用
17,先分页再用join



最左前缀匹配原则
    1，最左前缀匹配原则，MySQL会一直向右匹配直到遇到范围查询（>,<,between,like）就停止匹配 比如 a =1 and b=2 and c>3 and d = 4
        如果建立(a,b,c,d)索引，d用不到 如果是（a，b,d,c）则可以
    2，=和in 可以乱序，a=1 and b=2 and c = 3 建立（a,b,c）的索引可以任意顺序，MySQL的查询器会帮你优化索引

数据切分
    1,垂直切分： 把单一的表拆分多个表，分散到不同的数据库上
                 优点：
                    1，拆分后业务清晰，拆分的规则明确
                    2，系统之间的整合或者扩展很容易
                    3，便于管理和维护
                    4，实现动静分离，冷热分离


                 缺点：
                    1，部分业务表无法关联，只能通过接口的方式解决，提高了系统的复杂性
                    2，受某种业务的不同限制，存在单库性能瓶颈
                    3，事务复杂
    2，水平切分： 根据表中的数据逻辑关系，将同一个表中的数据按照某种条件拆分到数据库上
                 优点:
                    1,单库单表的数据保持在一定的量级，有利于性能的提高
                    2，切分后表的数据结构相同，应用层改动少
                    3，提高了系统的稳定性和负载能力

                 缺点：
                    1，切分后数据分散
                    2，拆分规则难以抽象
                    3，分片事务的一致性难以解决
                    4，数据扩容的难度和维护量极大

    1，哈希切片
    2，时间切片


    分区
        将一张表的数据结构分成多个存储区块，而数据结构不变，可以存储在同一磁盘也可以存储在不同的磁盘上
        1，主键或者唯一索引必须包含分区字段
        2，很多的时候，使用的分区就不要再使用主键，否则影响性能
        3，只能通过int类型的字段或者返回int类型的表达式来分区，通常是year或者to_days等函数
        4，分区的表不支持外键，先关的逻辑约束通过程序实现

    分区和分表的差异
        1，都能提高MySQL的性能，高并发下有一个良好的表现
        2，分区和分表不矛盾，可以互相配合，对于大访问量，并且数据比较多的表，可以采取分表和分区结合的方式，访问量不大，但表结构很多的表可以采取分区的方式
        3，分区相对于分表，操作方便，分表需要手动创建表
