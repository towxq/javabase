java基础
java环境变量，win的如下

JAVA_HOME  E:\jdk18  你的jdk安装位置
CLASSPATH .;%JAVA_HOME%\lib;%JAVA_HOME%\lib\tools.jar   这个不用变
PATH   后加上 %JAVA_HOME%\bin;%JAVA_HOME%\jre\bin;

CLASSPATH早期的版本用来告诉在哪找java类，会用到dt.jar和tools.jar,后来会自动寻找当前路径，和自动加载dt.jar和tools.jar，所以1.5以后的版本
可用不用设置CLASSPATH

java是纯粹面向对象的语言，面向对象的特征
1，封装
2，继承
3，多态

类是对某一事物的抽象的描述，对象是该类的具体的实现

标识符用于给程序中的类，方法名，变量的符号
1，可以是字母，下划线，数字，美元符号，数字不能打头
2，不能是java的保留字符
3，不能是空格
4，不包含其他特殊字符

java语言支持 基本变量和引用变量
基本变量：byte,short,int,long,char,float,double,boolean 8个

          byte  1字节  8位
          short 2字节  16位
          int   4字节  32位
          long  8字节  64位
          char  2字节  16位
          float 4字节  32位
          double 8字节 64位


&  逻辑 与
|  逻辑 或
！ 逻辑 非

&&  前后都是true返回  true
||  一个是true 返回true

this总指向该方法的对象
1，构造器中引用改构造器正在初始化的对象
2，在方法中引用调用改方法的对象

一个方法调用它本身就是递归，注意跳出

方法重载
同名方法，形参列表不同，就是重载

成员变量和局部变量
成员变量  类定义的变量
局部变量  方法定义的变量
成员变量分为 类变量和实例变量 static修饰类变量

访问级别
private-->default-->protected-->public

在一个构造器中调用一个重载的构造器用this 子类的构造器调用父类的构造器用super

初始代码块 初始代码块在构造器前执行，
只能是static修饰  是静态初始代码块，在普通代码块前执行

final修饰的类不能有子类，修饰的方法不能被重写，修饰的变量不能被更改

StringBuffer线程安全，StringBuilder线程不安全，所以性能略高


Java集合类主要有两个接口派生而出，collection和map
Collection2个子接口-----list实现类  -----LinkedList底层链表
						     		    ------ArrayList底层数组
		  			  -----set实现类
									    -----TreeSet底层是红黑树
							          -----HsahSet底层是哈希表
Map接口实现类------HashMap底层是数组和链表
			 	  -------TreeMap底层是红黑树（实现compare方法）



static的特点：
1，static是一个修饰符，用于修饰成员。
2，static修饰的成员被所有的对象所共享。
3，static优先于对象存在，因为static的成员随着类的加载就已经存在了。
4，static修饰的成员多了一种调用方式，就可以直接被类名所调用 。 类名.静态成员 。
5，static修饰的数据是共享数据，对象中的存储的是特有数据。

成员变量和静态变量的区别？
1，两个变量的生命周期不同。
	成员变量随着对象的创建而存在，随着对象的被回收而释放。
	静态变量随着类的加载而存在，随着类的消失而消失。

2，调用方式不同。
	成员变量只能被对象调用。
	静态变量可以被对象调用，还可以被类名调用。

3，别名不同。
	成员变量也称为实例变量。
	静态变量称为类变量。

4，数据存储位置不同。
	成员变量数据存储在堆内存的对象中，所以也叫对象的特有数据.
	静态变量数据存储在方法区(共享数据区)的静态区，所以也叫对象的共享数据.

静态什么时候用？
1，静态变量。
	当分析对象中所具备的成员变量的值都是相同的 。
	这时这个成员就可以被静态修饰。
	只要数据在对象中都是不同的，就是对象的特有数据，必须存储在对象中，是非静态的。
	如果是相同的数据，对象不需要做修改，只需要使用即可，不需要存储在对象中，定义成静态的。

2，静态函数。
	函数是否用静态修饰，就参考一点，就是该函数功能是否有访问到对象中的特有数据。
	简单点说，从源代码看，该功能是否需要访问非静态的成员变量，如果需要，该功能就是非静态的。
	如果不需要，就可以将该功能定义成静态的。当然，也可以定义成非静态，
	但是非静态需要被对象调用，而仅创建对象调用非静态的
	没有访问特有数据的方法，该对象的创建是没有意义。

异常
异常：是在运行时期发生的不正常情况。
最终问题（不正常情况）就分成了两大类。
Throwable:无论是error，还是异常，问题，问题发生就应该可以抛出，让调用者知道并处理。
			//该体系的特点就在于Throwable及其所有的子类都具有可抛性。
			可抛性到底指的是什么呢？怎么体现可抛性呢？
			其实是通过两个关键字来体现的。
			throws throw ,凡是可以被这两个关键字所操作的类和对象都具备可抛性.
	|--1，一般不可处理的。Error
			特点：是由jvm抛出的严重性的问题。
				 这种问题发生一般不针对性处理。直接修改程序
	|--2，可以处理的。Exception
注意：如果让一个类称为异常类，必须要继承异常体系，因为只有称为异常体系的子类才有资格具备可抛性。
	才可以被两个关键字所操作，throws throw

异常的分类：
1，编译时被检测异常:只要是Exception和其子类都是，除了特殊子类RuntimeException体系。
		这种问题一旦出现，希望在编译时就进行检测，让这种问题有对应的处理方式。
		这样的问题都可以针对性的处理。
2，编译时不检测异常(运行时异常):就是Exception中的RuntimeException和其子类。
		这种问题的发生，无法让功能继续，运算无法进行，更多是因为调用者的原因导致的而或者引发了内部状态的改变导致的。
		那么这种问题一般不处理，直接编译通过，在运行时，让调用者调用时的程序强制停止,让调用者对代码进行修正。

所以自定义异常时，要么继承Exception。要么继承RuntimeException。

throws 和throw的区别。
1，throws使用在函数上。
   throw使用在函数内。
2，throws抛出的是异常类，可以抛出多个，用逗号隔开。
   throw抛出的是异常对象。
异常处理的原则：
1，函数内容如果抛出需要检测的异常，那么函数上必须要声明。
	否则必须在函数内用trycatch捕捉，否则编译失败。

2，如果调用到了声明异常的函数，要么trycatch要么throws，否则编译失败。

3，什么时候catch，什么时候throws 呢？
	功能内容可以解决，用catch。
	解决不了，用throws告诉调用者，由调用者解决 。

4，一个功能如果抛出了多个异常，那么调用时，必须有对应多个catch进行针对性的处理。
	内部又几个需要检测的异常，就抛几个异常，抛出几个，就catch几个。

异常的注意事项：

1，子类在覆盖父类方法时，父类的方法如果抛出了异常，
那么子类的方法只能抛出父类的异常或者该异常的子类。
2，如果父类抛出多个异常，那么子类只能抛出父类异常的子集。
简单说：子类覆盖父类只能抛出父类的异常或者子类或者子集。
注意：如果父类的方法没有抛出异常，那么子类覆盖时绝对不能抛，就只能try .
