一、Java 基础
1.JDK 和 JRE 有什么区别？
    JDK:java development kit
    JRE:java runtime Environment
    JDK包含JRE

2.== 和 equals 的区别是什么？
    ==比较Java基础类型
    equals比较两个对象是否相等
3.两个对象的 hashCode()相同，则 equals()也一定为 true，对吗？
    不对，不同的对象可能会生成相同的hashcode值，当hashcode相同时在用equals比较
4.final 在 java 中有什么作用？
      final 修饰的类叫最终类，该类不能被继承。
      final 修饰的方法不能被重写。
      final 修饰的变量叫常量，常量必须初始化，初始化之后值就不能被修改。
5.java 中的 Math.round(-1.5) 等于多少？
       -1
6.String 属于基础的数据类型吗？
    不是
    8种基本数据类型： boolean byte char shrot int long float double
    对应的基本类型包装类：Boolean Byte Character Short Integer Long Float Double
7.java 中操作字符串都有哪些类？它们之间有什么区别？
    操作字符串的类有：String、StringBuffer、StringBuilder。
    String 和 StringBuffer、StringBuilder 的区别在于 String 声明的是不可变的对象，每次操作都会生成新的 String 对象，然后将指针指向新的 String 对象，而 StringBuffer、StringBuilder 可以在原有对象的基础上进行操作，所以在经常改变字符串内容的情况下最好不要使用 String。
    StringBuffer 和 StringBuilder 最大的区别在于，StringBuffer 是线程安全的，而 StringBuilder 是非线程安全的，但 StringBuilder 的性能却高于 StringBuffer，所以在单线程环境下推荐使用 StringBuilder，多线程环境下推荐使用 StringBuffer。
8.String str="i"与 String str=new String("i")一样吗？
   不一样，因为内存的分配方式不一样。String str="i"的方式，java 虚拟机会将其分配到常量池中；而 String str=new String("i") 则会被分到堆内存中。
9.如何将字符串反转？
    使用 StringBuilder 或者 stringBuffer 的 reverse() 方法。
10.String 类的常用方法都有那些？
    indexOf()：返回指定字符的索引。
    charAt()：返回指定索引处的字符。
    replace()：字符串替换。
    trim()：去除字符串两端空白。
    split()：分割字符串，返回一个分割后的字符串数组。
    getBytes()：返回字符串的 byte 类型数组。
    length()：返回字符串长度。
    toLowerCase()：将字符串转成小写字母。
    toUpperCase()：将字符串转成大写字符。
    substring()：截取字符串。
    equals()：字符串比较。

11.抽象类必须要有抽象方法吗？
    抽象类不一定要有抽象方法；但是有抽象方法的类一定是抽象类
12.普通类和抽象类有哪些区别？
    a.抽象类不能被实例化。
    b.抽象类可以有构造函数，被继承时子类必须继承父类一个构造方法，抽象方法不能被声明为静态。
    c.抽象方法只需申明，而无需实现，抽象类中可以允许普通方法有主体
    d.含有抽象方法的类必须申明为抽象类
    e.抽象的子类必须实现抽象类中所有抽象方法，否则这个子类也是抽象类。
13.抽象类能使用 final 修饰吗？
   不能，定义抽象类就是让其他类继承的，如果定义为 final 该类就不能被继承，这样彼此就会产生矛盾，所以 final 不能修饰抽象类
14.接口和抽象类有什么区别？
    默认方法实现：抽象类可以有默认的方法实现；接口不能有默认的方法实现。
    实现：抽象类的子类使用 extends 来继承；接口必须使用 implements 来实现接口。
    构造函数：抽象类可以有构造函数；接口不能有。
    main 方法：抽象类可以有 main 方法，并且我们能运行它；接口不能有 main 方法。
    实现数量：类可以实现很多个接口；但是只能继承一个抽象类。
    访问修饰符：接口中的方法默认使用 public 修饰；抽象类中的方法可以是任意访问修饰符。
15.java 中 IO 流分为几种？
    按功能来分：输入流（input）、输出流（output）。
    按类型来分：字节流和字符流。
    字节流和字符流的区别是：字节流按 8 位传输以字节为单位输入输出数据，字符流按 16 位传输以字符为单位输入输出数据。
16.BIO、NIO、AIO 有什么区别？
    BIO：Block IO 同步阻塞式 IO，就是我们平常使用的传统 IO，它的特点是模式简单使用方便，并发处理能力低。
    NIO：New IO 同步非阻塞 IO，是传统 IO 的升级，客户端和服务器端通过 Channel（通道）通讯，实现了多路复用。
    AIO：Asynchronous IO 是 NIO 的升级，也叫 NIO2，实现了异步非堵塞 IO ，异步 IO 的操作基于事件和回调机制。
17.Files的常用方法都有哪些？
    Files.exists()：检测文件路径是否存在。
    Files.createFile()：创建文件。
    Files.createDirectory()：创建文件夹。
    Files.delete()：删除一个文件或目录。
    Files.copy()：复制文件。
    Files.move()：移动文件。
    Files.size()：查看文件个数。
    Files.read()：读取文件。
    Files.write()：写入文件。
二、容器
18.java 容器都有哪些？
    数组,String,java.util下的集合容器
        HashSet 底层采用的HashMap的实现
        TreeSet 底层采用的HashMap的实现
            value域里面装的是同一个Object的引用
        LinkedList 双向链表，没有初始化大小，添加块
        ArrayList 底层是数组 初始大小是10，扩容后的大小 = 原始大小*1.5 读写块
        HashMap 无序的，方法是不同步的额，线程不安全,默认是16  JDK1.7是数组+链表  JDK1.8 是数组+链表+红黑树
        TreeMap 有序的
        Hashtable 无序的，方法是同步的，线程安全，hash数组的默认大小是11，增加的方式old*2+1
19.Collection 和 Collections 有什么区别？
    1、java.util.Collection 是一个集合接口。它提供了对集合对象进行基本操作的通用接口方法。
    Collection接口在Java 类库中有很多具体的实现。Collection接口的意义是为各种具体的集合提供了最大化的统一操作方式。
    2、java.util.Collections 是一个包装类。它包含有各种有关集合操作的静态多态方法。此类不能实例化，
    就像一个工具类，服务于Java的Collection框架
20.List、Set、Map 之间的区别是什么？
    List 有序集合，允许可重复
    Set  无序集合，不允许重复
    Map 键值对应，无序,元素可重复
21.HashMap 和 Hashtable 有什么区别？
    HashMap线程不安全，是Map的实现类，不包含重复键，允许null key 和Null value
    HashTable是线程安全的，不允许null key
22.如何决定使用 HashMap 还是 TreeMap？

23.说一下 HashMap 的实现原理？
    HashMap是基于哈希表的Map接口的非同步实现，
    允许使用null值和null键(HashMap最多只允许一条记录的键为null，允许多条记录的值为null。)。此类不保证映射的顺序，特别是它不保证该顺序恒久不变。
    HashMap中不允许出现重复的键（Key）
    Hashmap是非线程安全的，
    其迭代器是fail-fast的
    HashMap实际上是一个“链表散列”的数据结构，即数组和链表的结合体，（JDK1.8增加了红黑树部分,会将时间复杂度从O(n)降为O(logn)）。
    数据存储：先根据key的hashCode（使用key的hashCode()方法获取）重新计算hash值，根据hash值算出这个元素在数组中的位置（即下标）， 如果数组该位置上已经存放有其他元素了，那么在这个位置上的元素将以链表的形式存放，新加入的放在链头，最先加入的放在链尾。如果数组该位置上没有元素，就直接将该元素放到此数组中的该位置上。
    数据读取：首先根据key的hashCode，找到其数组中对应位置的数据(可能只有一个数据，也可能是多个数据，其表现形式是一个链表)，然后通过key的equals方法在对应位置的链表中找到需要的元素。
    hashMap的默认初始容量是16个，其会有一个负载因子，用于当hashMap中的数据量等于容量*负载因子时，hashMap会进行扩容，扩大的容量是原本的2倍。负载因子的默认初始值为0.75
24.说一下 HashSet 的实现原理？
    它是基于HashMap实现的，底层采用HashMap来保存元素，而且只使用了HashMap的key来实现各种特性。HashSet实现了Set接口
    HashSet较HashMap来说比较慢
    HashSet中的数据不是key-value键值对，其只是单值，虽然其借助与HashMap来实现，但是其只是将值作为key来存入HashMap中，因为HashMap中的值是key-value键值对的，所以每个HashSet存储到HashMap的数据对应的value值只是一个new Object()对象
    当添加数据时，如果set中尚未包含指定元素，则添加指定元素。更确切地讲，如果此 set 没有包含满足(e==null ? e2==null : e.equals(e2))的元素e2，则向此set 添加指定的元素e。如果此set已包含该元素，则该调用不更改set并返回false。但底层实际将将该元素作为key放入HashMap。
25.ArrayList 和 LinkedList 的区别是什么？
    ArrayList底层是数组，读快，写慢，需要扩容数组
    LinkedList底层为链表，写快，读慢

27.ArrayList 和 Vector 的区别是什么？
    Vertor是线程安全的

28.Array 和 ArrayList 有何区别？
    Array可以存储基本类型和对象类型，不能扩容
    ArrayList只能存储对象类型

30.哪些集合类是线程安全的？
    Vector,hashtable

31.迭代器 Iterator 是什么？
    迭代Collection的类

34.怎么确保一个集合不能被修改？
    Collections.unmodifiableList(List)
    Collections.unmodifiableSet(Set)

三、多线程
35.并行和并发有什么区别？
    并行：多个cpu实例或者多台机器处理执行一段处理逻辑，是真正的同时
    并发：通过CPU调度算法，让用户看上去同时执行，实际上从cpu操作层面不是真正的同时
36.线程和进程的区别？
    进程：每个进程都有独立的代码和数据空间（进程上下文），进程间的切换会有较大的开销，一个进程包含1--n个线程。（进程是资源分配的最小单位）
    线程：同一类线程共享代码和数据空间，每个线程有独立的运行栈和程序计数器(PC)，线程切换开销小。（线程是cpu调度的最小单位）
37.守护线程是什么？
    为用户线程服务的线程，需要在线程开始时设置

38.创建线程有哪几种方式？
    Thread run
    Runnable run
    Callable cal

39.说一下 runnable 和 callable 有什么区别？
    返回值

44.创建线程池有哪几种方式？

45.线程池都有哪些状态？

47.在 java 程序中怎么保证多线程的运行安全？

48.多线程锁的升级原理是什么？

49.什么是死锁？

50.怎么防止死锁？

51.ThreadLocal 是什么？有哪些使用场景？

52.说一下 synchronized 底层实现原理？

53.synchronized 和 volatile 的区别是什么？

54.synchronized 和 Lock 有什么区别？

55.synchronized 和 ReentrantLock 区别是什么？

56.说一下 atomic 的原理？

四、反射
57.什么是反射？
58.什么是 java 序列化？什么情况下需要序列化？
59.动态代理是什么？有哪些应用？
60.怎么实现动态代理？

六、Java Web
64.jsp 和 servlet 有什么区别？
65.jsp 有哪些内置对象？作用分别是什么？
66.说一下 jsp 的 4 种作用域？
67.session 和 cookie 有什么区别？
68.说一下 session 的工作原理？
69.如果客户端禁止 cookie 能实现 session 还能用吗？
70.spring mvc 和 struts 的区别是什么？
71.如何避免 sql 注入？
72.什么是 XSS 攻击，如何避免？
73.什么是 CSRF 攻击，如何避免？

七、异常
74.throw 和 throws 的区别？
75.final、finally、finalize 有什么区别？
76.try-catch-finally 中哪个部分可以省略？
77.try-catch-finally 中，如果 catch 中 return 了，finally 还会执行吗？
78.常见的异常类有哪些？

八、网络
79.http 响应码 301 和 302 代表的是什么？有什么区别？
80.forward 和 redirect 的区别？
81.简述 tcp 和 udp的区别？
82.tcp 为什么要三次握手，两次不行吗？为什么？
83.说一下 tcp 粘包是怎么产生的？
84.OSI 的七层模型都有哪些？
85.get 和 post 请求有哪些区别？
86.如何实现跨域？
87.说一下 JSONP 实现原理？

九、设计模式
88.说一下你熟悉的设计模式？
89.简单工厂和抽象工厂有什么区别？

十、Spring/Spring MVC
90.为什么要使用 spring？
91.解释一下什么是 aop？
92.解释一下什么是 ioc？
93.spring 有哪些主要模块？
94.spring 常用的注入方式有哪些？
95.spring 中的 bean 是线程安全的吗？
96.spring 支持几种 bean 的作用域？
97.spring 自动装配 bean 有哪些方式？
98.spring 事务实现方式有哪些？
99.说一下 spring 的事务隔离？
100.说一下 spring mvc 运行流程？
101.spring mvc 有哪些组件？
102.@RequestMapping 的作用是什么？
103.@Autowired 的作用是什么？

十三、Mybatis
125.mybatis 中 #{}和 ${}的区别是什么？
126.mybatis 有几种分页方式？
127.RowBounds 是一次性查询全部结果吗？为什么？
128.mybatis 逻辑分页和物理分页的区别是什么？
129.mybatis 是否支持延迟加载？延迟加载的原理是什么？
130.说一下 mybatis 的一级缓存和二级缓存？
131.mybatis 和 hibernate 的区别有哪些？
132.mybatis 有哪些执行器（Executor）？
133.mybatis 分页插件的实现原理是什么？
134.mybatis 如何编写一个自定义插件？

十六、Zookeeper
157.分布式 是什么？
158.分布式 都有哪些功能？
159.分布式 有几种部署模式？
160.分布式 怎么保证主从节点的状态同步？
161.集群中为什么要有主节点？
162.集群中有 3 台服务器，其中一个节点宕机，这个时候 分布式 还可以使用吗？
163.说一下 分布式 的通知机制？

十七、MySql
164.数据库的三范式是什么？
    第一范式：确保每一列都是原子性的。即每个属性都是不可能再分的最小数据单元。
	第二范式：满足第一范式的基础上，非主键必须完全依赖主键，而且不是仅仅依赖主键的部分。
	    第二范式需要确保数据库表中的每一列都和主键相关，而不能只与主键的某一部分相关（主要针对联合主键而言）。也就是说在一个数据库表中，
	    一个表中只能保存一种数据，不可以把多种数据保存在同一张数据库表中
	第三范式：需要确保数据表中的每一列数据都和主键直接相关，而不能间接相关。

165.一张自增表里面总共有 7 条数据，删除了最后 2 条数据，重启 mysql 数据库，又插入了一条数据，此时 id 是几？
166.如何获取当前数据库版本？
167.说一下 ACID 是什么？
    1，	原子性  一个事务是不可再分的
    2，	隔离性  事务所做的修改在提交前，对其他的事务是不可见的
    3，	一致性  一个状态转换到另一个状态，事务不提交所做的修改不会写到数据库
    4，	持久性  一旦提交会永久保存到数据库
168.char 和 varchar 的区别是什么？
    一个定长  一个变长
169.float 和 double 的区别是什么？

170.mysql 的内连接、左连接、右连接有什么区别？
    left join(左联接) 返回包括左表中的所有记录和右表中联结字段相等的记录
    right join(右联接) 返回包括右表中的所有记录和左表中联结字段相等的记录
    join(等值连接) 只返回两个表中联结字段相等的行
171.mysql 索引是怎么实现的？
172.怎么验证 mysql 的索引是否满足需求？
173.说一下数据库的事务隔离？
174.说一下 mysql 常用的引擎？
175.说一下 mysql 的行锁和表锁？
176.说一下乐观锁和悲观锁？

十八、Redis
179.redis 是什么？都有哪些使用场景？
    Redis是一个开源的内存中的数据结构存储系统，它可以用作：数据库、缓存和消息中间件。
180.redis 有哪些功能？
    它可以用作：数据库、缓存和消息中间件。
181.redis 和 memecache 有什么区别？
    (1) memcached所有的值均是简单的字符串，redis作为其替代者，支持更为丰富的数据类型
    (2) redis的速度比memcached快很多
    (3) redis可以持久化其数据
    (4)Redis支持数据的备份，即master-slave模式的数据备份
182.redis 为什么是单线程的？
    因为Redis是基于内存的操作，CPU不是Redis的瓶颈，Redis的瓶颈最有可能是机器内存的大小或者网络带宽。既然单线程容易实现，而且CPU不会成为瓶颈，那就顺理成章地采用单线程的方案了
183.什么是缓存穿透？怎么解决？
    缓存穿透是指查询一个一定不存在的数据，由于缓存是不命中时被动写的，并且出于容错考虑，如果从存储层查不到数据则不写入缓存，这将导致这个不存在的数据每次请求都要到存储层去查询，失去了缓存的意义。
184.redis 支持的数据类型有哪些？
    它支持多种类型的数据结构，如字符串（String），散列（Hash），列表（List），集合（Set），有序集合（Sorted Set或者是ZSet）与范围查询，Bitmaps，Hyperloglogs 和地理空间（Geospatial）
    索引半径查询。其中常见的数据结构类型有：String、List、Set、Hash、ZSet这5种。
185.redis 支持的 java 客户端都有哪些？
    Jedis、Redission
186.jedis 和 redisson 有哪些区别？
     Jedis是Redis的Java实现的客户端，其API提供了比较全面的Redis命令的支持；Redisson实现了分布式和可扩展的Java数据结构，和Jedis相比，功能较为简单，不支持字符串操作，不支持排序、事务、管道、分区等Redis特性，但是在集群模式下，
      Redisson为单个Redis集合类型提供了自动分片的功能，支持分布式对象，分布式集合，分布式锁。Redisson的宗旨是促进使用者对Redis的关注分离，从而让使用者能够将精力更集中地放在处理业务逻辑上。
187.怎么保证缓存和数据库数据的一致性？
188.redis 持久化有几种方式？
            1，快照
                bgsave redis会调用fork来创建一个子进程，子进程负责将快照写入硬盘，父进程继续处理请求，redis的内存越来越多的时候，bgsave在创建子进程时，所耗费的
                       时间会越来越久，所以会导致redis的性能降低。
                save redis服务在创建快照完毕之前不在响应其他任何的请求
            2，只追加文件
                AOF持久化会将执行的命令写到AOF文件的末尾，来记录变化。
189.redis 怎么实现分布式锁？
190.redis 分布式锁有什么缺陷？
191.redis 如何做内存优化？
192.redis 淘汰策略有哪些？
    volatile-lru：从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用的数据淘汰
    volatile-ttl：从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰
    volatile-random：从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰
    allkeys-lru：从数据集（server.db[i].dict）中挑选最近最少使用的数据淘汰
    allkeys-random：从数据集（server.db[i].dict）中任意选择数据淘汰
    no-enviction（驱逐）：禁止驱逐数据
    volatile和allkeys规定了是对已设置过期时间的数据集淘汰数据还是从全部数据集淘汰数据，后面的lru、ttl以及random是三种不同的淘汰策略，再加上一种no-enviction永不回收的策略
    使用策略规则：
    　　1、如果数据呈现幂律分布，也就是一部分数据访问频率高，一部分数据访问频率低，则使用allkeys-lru
    　　2、如果数据呈现平等分布，也就是所有的数据访问频率都相同，则使用allkeys-random
193.redis 常见的性能问题有哪些？该如何解决？
    (1) Master最好不要做任何持久化工作，如RDB内存快照和AOF日志文件
        Master写内存快照，save命令调度rdbSave函数，会阻塞主线程的工作，当快照比较大时对性能影响是非常大的，会间断性暂停服务，所以Master最好不要写内存快照;AOF文件过大会影响Master重启的恢复速度)
    (2) 如果数据比较重要，某个Slave开启AOF备份数据，策略设置为每秒同步一次
    (3) 为了主从复制的速度和连接的稳定性，Master和Slave最好在同一个局域网内
    (4) 尽量避免在压力很大的主库上增加从库
    (5) 主从复制不要用图状结构，用单向链表结构更为稳定，即：Master <- Slave1 <- Slave2 <- Slave3...

十九、JVM
194.说一下 jvm 的主要组成部分？及其作用？
195.说一下 jvm 运行时数据区？
196.说一下堆栈的区别？
197.队列和栈是什么？有什么区别？
198.什么是双亲委派模型？
199.说一下类加载的执行过程？
200.怎么判断对象是否可以被回收？
201.java 中都有哪些引用类型？
202.说一下 jvm 有哪些垃圾回收算法？
203.说一下 jvm 有哪些垃圾回收器？
204.详细介绍一下 CMS 垃圾回收器？
205.新生代垃圾回收器和老生代垃圾回收器都有哪些？有什么区别？
206.简述分代垃圾回收器是怎么工作的？
207.说一下 jvm 调优的工具？
208.常用的 jvm 调优的参数都有哪些？

1.ThreadLocal 是什么？
ThreadLocal 是一个本地线程副本变量工具类。主要用于将私有线程和该线程存放的副本对象做一个映射，
各个线程之间的变量互不干扰，在高并发场景下，可以实现无状态的调用，适用于各个线程不共享变量值的操作。

2.ThreadLocal 工作原理是什么？
ThreadLocal 原理：每个线程的内部都维护了一个 ThreadLocalMap，它是一个 Map（key,value）数据格式，
key 是一个弱引用，也就是 ThreadLocal 本身，而 value 存的是线程变量的值。
也就是说 ThreadLocal 本身并不存储线程的变量值，它只是一个工具，用来维护线程内部的 Map，帮助存和取变量。

3.ThreadLocal 如何解决 Hash 冲突？
与 HashMap 不同，ThreadLocalMap 结构非常简单，没有 next 引用，也就是说 ThreadLocalMap 中解决 Hash 冲突的方式并非链表的方式，
而是采用线性探测的方式。所谓线性探测，就是根据初始 key 的 hashcode 值确定元素在 table 数组中的位置，
如果发现这个位置上已经被其他的 key 值占用，则利用固定的算法寻找一定步长的下个位置，依次判断，直至找到能够存放的位置。

4.ThreadLocal 的内存泄露是怎么回事？
ThreadLocal 在 ThreadLocalMap 中是以一个弱引用身份被 Entry 中的 Key 引用的，因此如果 ThreadLocal 没有外部强引用来引用它，
那么 ThreadLocal 会在下次 JVM 垃圾收集时被回收。这个时候 Entry 中的 key 已经被回收，但是 value 又是一强引用不会被垃圾收集器回收，
这样 ThreadLocal 的线程如果一直持续运行，value 就一直得不到回收，这样就会发生内存泄露。

5.为什么 ThreadLocalMap 的 key 是弱引用？
我们知道 ThreadLocalMap 中的 key 是弱引用，而 value 是强引用才会导致内存泄露的问题，至于为什么要这样设计，这样分为两种情况来讨论：
key 使用强引用：这样会导致一个问题，引用的 ThreadLocal 的对象被回收了，但是 ThreadLocalMap 还持有 ThreadLocal 的强引用，
如果没有手动删除，ThreadLocal 不会被回收，则会导致内存泄漏。
key 使用弱引用：这样的话，引用的 ThreadLocal 的对象被回收了，由于 ThreadLocalMap 持有 ThreadLocal 的弱引用，
即使没有手动删除，ThreadLocal 也会被回收。value 在下一次 ThreadLocalMap 调用 set、get、remove 的时候会被清除。
比较以上两种情况，我们可以发现：由于 ThreadLocalMap 的生命周期跟 Thread 一样长，如果都没有手动删除对应 key，都会导致内存泄漏，
但是使用弱引用可以多一层保障，弱引用 ThreadLocal 不会内存泄漏，对应的 value 在下一次 ThreadLocalMap 调用 set、get、remove 的时候被清除，
算是最优的解决方案。

6.ThreadLocal 的应用场景有哪些？
ThreadLocal 适用于独立变量副本的情况，比如 Hibernate 的 session 获取场景。

网络七层协议
    ISO的OSI模型                                                                       TCP/IP 模型
        应用层   各种应用的协议(电子邮件,文件传输协议，远程登录协议）                             应用层   ARP  RARP
        表示层   数据格式标识，基本压缩和解密                                                    传输层     ICMP  IP
        会话层   控制应用程序之间的会话能力，不同软件的数据分发给不同的软件                        互联网层   TCP   UDP
                                                                                               网络访问层   DNS  FTP  HTTP  SMTP
        传输层   端到端的传输数据的基本功能，如TCP  UDP
        网络层   定义IP地址，定义路由功能，如不同设备的数据转发
        数据链路层   定义数据的基本格式，如何传输，如何标识，如MAC地址

        物理层   底层数据传输，如网线，网卡标准


数据库的锁（行锁，表锁，页级锁，意向锁，读锁，写锁，悲观锁，乐观锁）
    表级锁（锁定整个表）
    页级锁（锁定一页）  BDB引擎
    行级锁（锁定一行）

    MyISAM
        表共享读锁 （Table Read Lock）：不会阻塞其他用户对同一表的读请求，但会阻塞对同一表的写请求；
        表独占写锁 （Table Write Lock）：会阻塞其他用户对同一表的读和写操作；

        MyISAM 在执行查询语句（SELECT）前，会自动给涉及的表加读锁，在执行更新操作
        （UPDATE、DELETE、INSERT 等）前，会自动给涉及的表加写锁，这个过程并不需要用户干预，因此，用户一般不需要直接用 LOCK TABLE 命令给 MyISAM 表显式加锁。

    InnoDB
        InnoDB 实现了以下两种类型的行锁：
            共享锁（S）：允许一个事务去读一行，阻止其他事务获得相同数据集的排他锁。
            排他锁（X）：允许获得排他锁的事务更新数据，阻止其他事务取得相同数据集的共享读锁和排他写锁。

        为了允许行锁和表锁共存，实现多粒度锁机制，InnoDB 还有两种内部使用的意向锁（Intention Locks），这两种意向锁都是表锁：
            意向共享锁（IS）：事务打算给数据行加行共享锁，事务在给一个数据行加共享锁前必须先取得该表的 IS 锁。
            意向排他锁（IX）：事务打算给数据行加行排他锁，事务在给一个数据行加排他锁前必须先取得该表的 IX 锁。

        InnoDB加锁方法
            1，意向锁是 InnoDB 自动加的， 不需用户干预。
            2，对于 UPDATE、 DELETE 和 INSERT 语句， InnoDB
               会自动给涉及数据集加排他锁（X)；
            3，对于普通 SELECT 语句，InnoDB 不会加任何锁；
            事务可以通过以下语句显式给记录集加共享锁或排他锁：
                共享锁（S）：SELECT * FROM table_name WHERE ... LOCK IN SHARE MODE。 其他 session 仍然可以查询记录，并也可以对该记录加 share mode 的共享锁。
                但是如果当前事务需要对该记录进行更新操作，则很有可能造成死锁。
                排他锁（X)：SELECT * FROM table_name WHERE ... FOR UPDATE。其他 session 可以查询该记录，但是不能对该记录加共享锁或排他锁，而是等待获得锁

        隐式锁定
            InnoDB在事务执行过程中，使用两阶段锁协议：
            随时都可以执行锁定，InnoDB会根据隔离级别在需要的时候自动加锁；
            锁只有在执行commit或者rollback的时候才会释放，并且所有的锁都是在同一时刻被释放


        InnoDB 行锁实现方式：
            1，InnoDB 行锁是通过给索引上的索引项加锁来实现的，这一点 MySQL 与 Oracle 不同，后者是通过在数据块中对相应数据行加锁来实现的。InnoDB 这种行锁实现特点意味着：只有通过索引条件检索数据，InnoDB 才使用行级锁，否则，InnoDB 将使用表锁！
            2，不论是使用主键索引、唯一索引或普通索引，InnoDB 都会使用行锁来对数据加锁。
            3，只有执行计划真正使用了索引，才能使用行锁：即便在条件中使用了索引字段，但是否使用索引来检索数据是由 MySQL 通过判断不同执行计划的代价来决定的，如果 MySQL 认为全表扫描效率更高，比如对一些很小的表，它就不会使用索引，这种情况下 InnoDB 将使用表锁，而不是行锁。因此，在分析锁冲突时，
               别忘了检查 SQL 的执行计划（可以通过 explain 检查 SQL 的执行计划），以确认是否真正使用了索引。（更多阅读：MySQL索引总结）
            4，由于 MySQL 的行锁是针对索引加的锁，不是针对记录加的锁，所以虽然多个session是访问不同行的记录， 但是如果是使用相同的索引键， 是会出现锁冲突的（后使用这些索引的session需要等待先使用索引的session释放锁后，才能获取锁）。 应用设计的时候要注意这一点。

    悲观锁（Pessimistic Concurrency Control，PCC）：假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作。至于怎么加锁，加锁的范围也没讲。
        悲观锁，顾名思义，就是很悲观，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会block直到它拿到锁。
        传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。

    乐观锁（Optimistic Concurrency Control，OCC）：假设不会发生并发冲突，只在提交操作时检查是否违反数据完整性。也没具体指定怎么检查。
        乐观锁, 顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，
        可以使用版本号等机制。乐观锁适用于多读的应用类型，这样可以提高吞吐量，像数据库如果提供类似于write_condition机制的其实都是提供的乐观锁。

以及加锁的select sql方式优化（explain，慢查询，show profile）分库分表，主从复制，读写分离

    主从复制
        1，基于语句的复制
            主服务器上面执行的语句在从服务器上在执行一遍
            存在问题：时间上可能不完全同步造成偏差，执行语句的用户可能不是同一个用户
        2，基于行的复制
            把主服务器上面改编后的内容直接复制过去，而不关心到底是那条语句引发的
        3，混合复制
            默认基于语句，当基于语句的复制会引发问题的时候就会基于行复制，MySQL会自动进行选择
            读操作可以在所有的服务器上进行，而写操作只能在主服务器上进行

    读写分离
        1，应用层分离  访问数据库的时候配置多数据源，然后分流
        2，代理实现   在应用层和数据库集群之间添加一个代理服务器，应用层访问代理层，代理根据请求的类型自动分流到不同的数据库



Java序列化
    　  把对象转换为字节序列的过程称为对象的 序列化。
    　　把字节序列恢复为对象的过程称为对象的 反序列化。

    　　对象的序列化主要有两种用途：
    　　1） 把对象的字节序列永久地保存到硬盘上，通常存放在一个文件中；
    　　2） 在网络上传送对象的字节序列。

        s​e​r​i​a​l​V​e​r​s​i​o​n​U​I​D​:​ ​字​面​意​思​上​是​序​列​化​的​版​本​号​，凡是实现Serializable接口的类都有一个表示序列化版本标识符的静态变量
                          SerialVersionUID用于对象的版本控制。当您添加或修改类中的任何字段时，已经序列化的类将无法恢复，
                          因为serialVersionUID已为新类生成与旧的序列化对象将不同。Java序列化过程依赖于正确的serialVersionUID恢复序列化对象的状态，
                          并在serialVersionUID不匹配时抛出java.io.InvalidClassException 异常。


            显式地定义serialVersionUID有两种用途：
        　　　　1、 在某些场合，希望类的不同版本对序列化兼容，因此需要确保类的不同版本具有相同的serialVersionUID；
        　　　　2、 在某些场合，不希望类的不同版本对序列化兼容，因此需要确保类的不同版本具有不同的serialVersionUID。

        Transient 关键字
            transient修饰符仅适用于变量，不适用于方法和类。在序列化时，如果我们不想序列化特定变量以满足安全约束，那么我们应该将该变量声明为transient。
            执行序列化时，JVM会忽略transient变量的原始值并将默认值保存到文件中。因此，transient意味着不要序列化。


线程池，SYNC和Lock锁机制、线程通信、volatile、ThreadLocal、CyclicBarrier、Atom包、CountDownLatch、AQS、CAS原理内存模型
GC垃圾回收，包括分代，GC算法，收集器、类加载和双亲委派、JVM调优，内存泄漏和内存溢出反射和代  理、异常、
Java8相关、序列化 servlet、cookie session、Spring AOP、IOC、MVC、事务、动态代理、Mybatis、Tomcat等等相关知识服务发现、治理等，
分布式、dubbo、springcloud微服务原理、kafka，activeMQ，rocketMQ





商品30万
6000万  60万单
线上 800多万  4万单
58万会员
付费会员4000 
线上周转 70
门店周转  80
