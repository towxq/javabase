网络七层协议
    ISO的OSI模型                                                                       TCP/IP 模型
        应用层   各种应用的协议(电子邮件,文件传输协议，远程登录协议）                             应用层   ARP  RARP
        表示层   数据格式标识，基本压缩和解密                                                    传输层     ICMP  IP
        会话层   控制应用程序之间的会话能力，不同软件的数据分发给不同的软件                        互联网层   TCP   UDP
                                                                                               网络访问层   DNS  FTP  HTTP  SMTP
        传输层   端到端的传输数据的基本功能，如TCP  UDP
        网络层   定义IP地址，定义路由功能，如不同设备的数据转发
        数据链路层   定义数据的基本格式，如何传输，如何标识，如MAC地址

        物理层   底层数据传输，如网线，网卡标准


HTTP位于网络协议栈的应用层，而TCP位于网络协议栈的传输层，两者的KEEP-ALIVE虽然名称相同，但是作用不同。
HTTP是为了重用TCP，避免每次请求，都重复创建TCP；而TCP的KEEP-ALIVE是一种保活机制，检测对端是否依然存活。

HTTP  超文本传输协议  HTTP是一个基于TCP/IP通信协议来传递数据
1. 需要知道协议中的Method,Header,Cookies.
2. 知道常见状态码含义
3. 了解HTTPS的交互流程
4. QUIC基于UDP实现原HTTP功能,现已被标准化为HTTP3协议

HTTPS
    http协议都是明文传输的，HTTPS的目的是将这些内容加密，确保信息的传输安全，最后一个S指的是SSL/TLS协议

    信息安全
        1，客户端和服务器之间的通信
        2，第三方拿到数据也没用
        3，避免中间人的攻击

HTTP2.0
    多路复用
        对于HTTP1.X即使开启长连接，也是串行发送，2.0采用多路复用，可以并发的发送多个请求
    数据优先级
        由于数据都可以发送，可以设置客户端和服务端处理的不同的优先策略
    服务端推送
        服务端可以向客户端发送请求之外的内容
    头部压缩
        对于相同的内容，不会再次请求和响应发送



TCP
1. TCP和HTTP在服务交互中使用最多.了解报文标志状态和链接状态有利于抓包分析.
2. Nagel算法是为了解决小包问题和数据载荷比.
3. KeepALive是在长时间没有数据发送的情况下保持连接可用的机制.需要了解开启和设置方式.
4. 了解如何通过滑动窗口机制实现流量控制.

TCP三次握手
    （1）第一次握手：Client将标志位SYN置为1，随机产生一个值seq=J，并将该数据包发送给Server，Client进入SYN_SENT状态，等待Server确认。
    （2）第二次握手：Server收到数据包后由标志位SYN=1知道Client请求建立连接，Server将标志位SYN和ACK都置为1，ack=J+1，随机产生一个值seq=K，
                    并将该数据包发送给Client以确认连接请求，Server进入SYN_RCVD状态。
    （3）第三次握手：Client收到确认后，检查ack是否为J+1，ACK是否为1，如果正确则将标志位ACK置为1，ack=K+1，并将该数据包发送给Server，
                    Server检查ack是否为K+1，ACK是否为1，如果正确则连接建立成功，Client和Server进入ESTABLISHED状态，完成三次握手，随后Client与Server之间可以开始传输数据了。

    简单来说，就是
        1、建立连接时，客户端发送SYN包（SYN=i）到服务器，并进入到SYN-SEND状态，等待服务器确认
        2、服务器收到SYN包，必须确认客户的SYN（ack=i+1）,同时自己也发送一个SYN包（SYN=k）,即SYN+ACK包，此时服务器进入SYN-RECV状态
        3、客户端收到服务器的SYN+ACK包，向服务器发送确认报ACK（ack=k+1）,此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手，客户端与服务器开始传送数据。

TCP四次挥手
      由于TCP连接时全双工的，因此，每个方向都必须要单独进行关闭，这一原则是当一方完成数据发送任务后，发送一个FIN来终止这一方向的连接，
      收到一个FIN只是意味着这一方向上没有数据流动了，即不会再收到数据了，但是在这个TCP连接上仍然能够发送数据，直到这一方向也发送了FIN。
      首先进行关闭的一方将执行主动关闭，而另一方则执行被动关闭

    （1）第一次挥手：Client发送一个FIN，用来关闭Client到Server的数据传送，Client进入FIN_WAIT_1状态。
    （2）第二次挥手：Server收到FIN后，发送一个ACK给Client，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号），Server进入CLOSE_WAIT状态。
    （3）第三次挥手：Server发送一个FIN，用来关闭Server到Client的数据传送，Server进入LAST_ACK状态。
    （4）第四次挥手：Client收到FIN后，Client进入TIME_WAIT状态，接着发送一个ACK给Server，确认序号为收到序号+1，Server进入CLOSED状态，完成四次挥手。

为什么建立连接是三次握手，而关闭连接却是四次挥手呢？
    A向B发起建立连接请求：A——>B；
    B收到A的发送信号，并且向A发送确认信息：B——>A；
    A收到B的确认信号，并向B发送确认信号：A——>B。

    三次握手大概就是这么个过程。
    通过第一次握手，B知道A能够发送数据。通过第二次握手，A知道B能发送数据。结合第一次握手和第二次握手，A知道B能接收数据。结合第三次握手，B知道A能够接收数据。

    A向B发起请求，表示A没有数据要发送了：A——>B；
    B向A发送信号，确认A的断开请求请求：B——>A；
    B向A发送信号，请求断开连接，表示B没有数据要发送了：B——>A；
    A向B发送确认信号，同意断开：A——>B。

    挥手次数比握手多一次，是因为握手过程，通信只需要处理连接。而挥手过程，通信需要处理数据+连接。

    举个例子：A 和 B 打电话，通话即将结束后，A 说“我没啥要说的了”，B回答“我知道了”，但是 B 可能还会有要说的话，
    A 不能要求 B 跟着自己的节奏结束通话，于是 B 可能又巴拉巴拉说了一通，最后 B 说“我说完了”，A 回答“知道了”，这样通话才算结束。


为何HOSTA要在2MSL(Maximum Segment Lifetime 最大报文生存时长)后才关闭连接?
    要保证TCP的全双工连接能可靠关闭
    要保证这次连接中重复的数据段从网络中消失,防止端口重用时可能的数据混淆


请求方法（Request Method）
    GET POST
请求的网址（Request URL）
    请求的网址，即统一资源定位符URL，它可以唯一确定我们想请求的资源。
请求头（Request Headers）
    Accept  请求报头域，用于指定客户端可接受哪些类型的信息
    Accept-Language：指定客户端可接受的语言类型。
    Accept-Encoding：指定客户端可接受的内容编码。
    Host：用于指定请求资源的主机IP和端口号，其内容为请求URL的原始服务器或网关的位置
    Cookie:
    Referer:此内容用来标识这个请求是从哪个页面发过来的，服务器可以拿到这一信息并做相应的处理
    User-Agent：简称UA，它是一个特殊的字符串头，可以使服务器识别客户使用的操作系统及版本、浏览器及版本等信息。在做爬虫时加上此信息，可以伪装为浏览器；如果不加，很可能会被识别出为爬虫。
    Content-Type:在HTTP协议消息头中，它用来表示具体请求中的媒体类型信息
请求体（Request Body)
    请求体一般承载的内容是POST请求中的表单数据，而对于GET请求，请求体则为空。



响应状态码（Response Status Code）
    响应状态码表示服务器的响应状态，如200代表服务器正常响应，404代表页面未找到，500代表服务器内部发生错误
响应头（Response Headers）
    Date：标识响应产生的时间。
    Last-Modified：指定资源的最后修改时间。
    Content-Encoding：指定响应内容的编码。
    Server：包含服务器的信息，比如名称、版本号等。
    Content-Type：文档类型，指定返回的数据类型是什么，如text/html代表返回HTML文档，application/x-javascript则代表返回JavaScript文件，image/jpeg则代表返回图片。
    Set-Cookie：设置Cookies。响应头中的Set-Cookie告诉浏览器需要将此内容放在Cookies中，下次请求携带Cookies请求。
    Expires：指定响应的过期时间，可以使代理服务器或浏览器将加载的内容更新到缓存中。如果再次访问时，就可以直接从缓存中加载，降低服务器负载，缩短加载时间。
响应体（Response Body）
    最重要的当属响应体的内容了。响应的正文数据都在响应体中，比如请求网页时，它的响应体就是网页的HTML代码；请求一张图片时，它的响应体就是图片的二进制数据




