package 基础知识.多线程;

import sun.awt.windows.ThemeReader;

public class VolatileDemo {
        volatile int inc = 0;

        void increase(){
            inc++;
        }

        public static void main(String[] args){
            final VolatileDemo v = new VolatileDemo();
            for (int i=0;i<10;i++){
                new Thread(){
                    public void run(){
                        for (int n=0;n<1000;n++){
                            v.increase();
                        }
                    }
                }.start();
            }

            while(Thread.activeCount()>1){
                Thread.yield();
                System.out.println(v.inc);
            }
        }
}


//并发编程的三个重要特征
//    原子性：在一次操作或者多次操作中，要么所有操作全部执行并且不会受到任何因素的干扰而中断，要么所有操作都不执行。
//               a,多个原子操作在一起就不在是原子操作了
//               b,简单的读取与赋值是原子操作，将一个变量赋给另外一个变量的操作不是原子性的
//               c,Java内存模型只保证了基本读取和赋值的原子性操作，其他的均不保证，如果想要使得某些代码片段具备原子性，
//                 需要使用关键字synchronized或者JUC的lock,想使自增具备原子性可以使用JUC包下的atomic
//    有序性：当一个线程对共享变量进行了修改，那么另外的线程可以立即看到修改的值
//    可见性：代码在执行过程中的先后顺序


//java提供三种方式保证可见性
//    1，当一个变量被关键字volatile修饰时，对于共享资源的读操作会直接在主内存中进行，对于共享内存的写操作当然是先要修改工作内存，修改结束后
//        立即刷新到主内存中
//    2，通过synchronized关键字保证可见性，synchronized关键字能够保证同一时刻只有一个线程获得锁，然后执行同步方法，并且还会确保锁释放之前
//        会将变量的修改刷新到主内存中
//    3，通过JUC提供的显式锁Lock也能够保证可见性，Lock的lock方法能够保证在同一时刻只有一个线程获得锁然后执行同步方法，并且会确保在锁释放（Lock的unlock）
//        之前会将对变量的修改刷新到主内存中
//
//Java提供三种保证有序性的方式
//    1，使用volatile关键字来保证有序性
//    2，使用synchronized关键字来保证有序性
//    3，使用显式锁Lock保证有序性
//    后两者采用了同步的机制，同步代码在执行的时候与在单线程情况下自然能够保证顺序性
//
//
//Happens-before原则
//    程序次序规则：在一个线程内，代码按照编写的次序执行，编写在后面的操作发生于编写在前面的操作之后
//    锁定规则：一个unlock操作要先行发生于对同一个锁的lock操作
//    volatile变量规则：对一个变量的写操作要早于对这个变量之后的读操作
//    传递规则：如果操作A先与操作B，而操作B又先与操作C，则可以得出操作A肯定先于操作C
//    线程启动规则：Thread对象的start()方法先行发生于对该线程的任何操作
//    线程中断规则：对线程执行interrupt()方法肯定要优于捕获到中断信号，意思是如果线程收到中断信号，那么在此之前势必要有interrupt()
//    线程的终结规则：线程中所有的操作都要先行发生于线程的终止操作
//    对象的终结规则：一个对象初始化的完成先行发生于finalize()方法之前

//volatile是如何保证可见性以及顺序性
//    被volatile修饰的变量存在于一个 "lock"
//    "lock" 前缀实际上相当于是一个内存屏障，该内存屏障会为指令的执行提供如下几个保障
//        1，确保指令重排序时不会将其后面的代码排到内存屏障之前
//        2，确保指令重排序时不会将其前面的代码排到内存屏障之后
//        3，确保在执行到内存屏障修饰的指令时前面的代码全部执行完成
//        4，强制将线程工作内存中的值得修改刷新到主内存中
//        5，如果是写操作，则会导致其他线程工作内存（CPU Cache）中的缓存数据失败

//一旦一个变量被volatile修饰后
//1，保证了不同线程对这个变量的操作时的可见性，就是一个线程修改了某个变量得值，对其他线程是立即可见的
//2，禁止进行指令重排序

//volatile关键字禁止指令重排序有两层意思
//1，当程序执行到volatile变量得读操作或者写操作时，在其前面的操作的更改肯定全部进行，且结果已经对后面的操作可见，在其后面的操作肯定还没进行
//2，进行指令优化时，不能将在对volatile变量访问的语句放在其后面执行，也不能把volatile变量后面的语句放到其前面执行
//
//
//使用volatile必须具备两个条件
//1，对变量的写操作不依赖于当前值
//2，该变量没有包含在具有其他变量的不等式中
//    1，标记变量  2，double check
